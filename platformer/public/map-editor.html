<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Platformer Map Editor</title>
  <style>
    html, body { margin:0; padding:0; height:100%; overflow:hidden; }
    body { display:flex; flex-direction:column; height:100vh; background:#111; color:#eee; font-family:"Segoe UI",sans-serif; }

    #toolbar { background:#1a1a1a; padding:8px; display:flex; gap:8px; align-items:center; border-bottom:1px solid #333; }
    button { background:#3b82f6; color:#fff; border:none; border-radius:4px; padding:6px 10px; cursor:pointer; }
    button:hover { background:#2563eb; }
    label { font-size:12px; opacity:0.9; }
    select, input[type="range"] { background:#111; color:#eee; border:1px solid #333; }

    /* Canvas fills remaining vertical space between toolbar and output */
    #canvas { flex:1; display:block; background:#222; cursor:crosshair; }

    /* Output JSON box */
    #output { height:120px; margin-top:8px; background:#111; color:#eee; border:1px solid #333; }
  </style>
</head>
<body>
  <div id="toolbar">
    <button id="backBtn">Back to Game</button>
    <button id="saveBtn">Save Map</button>
    <button id="loadBtn">Load Map</button>
    <label>Rotation: <input id="rotationInput" type="range" min="0" max="360" value="0"></label>
    <label>Material:
      <select id="materialSelect">
        <option value="normal">Normal</option>
        <option value="ice">Ice</option>
        <option value="lava">Lava</option>
        <option value="bounce">Bounce</option>
        <option value="sticky">Sticky</option>
      </select>
    </label>
  </div>

  <canvas id="canvas"></canvas>
  <textarea id="output" placeholder="Map JSON will appear here..."></textarea>

  <script>
    // Canvas + controls
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const output = document.getElementById('output');
    const rotationInput = document.getElementById('rotationInput');
    const materialSelect = document.getElementById('materialSelect');
    document.getElementById('backBtn').onclick = () => { window.location.href = '/'; };

    // Responsive canvas: match parent and account for toolbar/output
    function resizeCanvas() {
      const parent = canvas.parentElement;
      const toolbarH = document.getElementById('toolbar').offsetHeight;
      const outputH = document.getElementById('output').offsetHeight;
      const w = parent.clientWidth;
      const h = parent.clientHeight - toolbarH - outputH;
      if (w > 0 && h > 0) {
        canvas.width = w;
        canvas.height = h;
      } else {
        canvas.width = window.innerWidth;
        canvas.height = Math.max(0, window.innerHeight - toolbarH - outputH);
      }
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    new ResizeObserver(resizeCanvas).observe(canvas.parentElement);

    // Editor state
    let platforms = [];
    let selected = null;
    let dragging = false;
    let dragOffset = {x:0,y:0};
    const grid = 25;

    // Render loop
    function render() {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle='#222';
      ctx.fillRect(0,0,canvas.width,canvas.height);

      // Grid
      ctx.strokeStyle='#333';
      ctx.lineWidth = 1;
      for(let x=0;x<canvas.width;x+=grid){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke(); }
      for(let y=0;y<canvas.height;y+=grid){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); ctx.stroke(); }

      // Platforms
      platforms.forEach(p=>{
        ctx.save();
        ctx.translate(p.x + p.w/2, p.y + p.h/2);
        ctx.rotate((p.rotation||0) * Math.PI/180);
        const colors = { normal:"#888", ice:"#3b82f6", lava:"#ef4444", bounce:"#facc15", sticky:"#10b981" };
        ctx.fillStyle = (p===selected) ? '#60a5fa' : (colors[p.material] || '#888');
        ctx.fillRect(-p.w/2, -p.h/2, p.w, p.h);
        ctx.restore();
      });

      requestAnimationFrame(render);
    }
    render();

    // Helpers
    function snap(v) { return Math.round(v / grid) * grid; }

    function hitTest(mx, my) {
      // Transform point into each platform's local space and do a box test
      for (let i=platforms.length-1;i>=0;i--) {
        const p = platforms[i];
        const cx = p.x + p.w/2, cy = p.y + p.h/2;
        const ang = (p.rotation||0) * Math.PI/180;
        const cos = Math.cos(-ang), sin = Math.sin(-ang);
        const lx = (mx - cx) * cos - (my - cy) * sin;
        const ly = (mx - cx) * sin + (my - cy) * cos;
        if (lx >= -p.w/2 && lx <= p.w/2 && ly >= -p.h/2 && ly <= p.h/2) return p;
      }
      return null;
    }

    // Mouse events
    canvas.addEventListener('mousedown', e=>{
      const rect=canvas.getBoundingClientRect();
      const mx=e.clientX-rect.left, my=e.clientY-rect.top;
      selected = hitTest(mx, my);
      if (selected) {
        dragging = true;
        dragOffset.x = mx - selected.x;
        dragOffset.y = my - selected.y;
        rotationInput.value = selected.rotation || 0;
        materialSelect.value = selected.material || 'normal';

        // Right click deletes
        if (e.button===2) {
          platforms = platforms.filter(p=>p!==selected);
          selected=null;
          dragging=false;
        }
      } else {
        const newPlat = { x: snap(mx), y: snap(my), w: 100, h: 20, rotation: 0, material: 'normal' };
        platforms.push(newPlat);
        selected = newPlat;
        rotationInput.value = 0;
        materialSelect.value = 'normal';
      }
    });

    canvas.addEventListener('mousemove', e=>{
      if (!dragging || !selected) return;
      const rect=canvas.getBoundingClientRect();
      const mx=e.clientX-rect.left, my=e.clientY-rect.top;
      selected.x = snap(mx - dragOffset.x);
      selected.y = snap(my - dragOffset.y);
    });

    canvas.addEventListener('mouseup', ()=>{ dragging=false; });
    canvas.addEventListener('mouseleave', ()=>{ dragging=false; });
    canvas.addEventListener('contextmenu', e=>e.preventDefault());

    // Controls
    rotationInput.addEventListener('input', () => {
      if (selected) selected.rotation = parseInt(rotationInput.value, 10) || 0;
    });

    materialSelect.addEventListener('change', () => {
      if (selected) selected.material = materialSelect.value;
    });

    // Save / Load
    document.getElementById('saveBtn').onclick=()=>{
      output.value=JSON.stringify(platforms,null,2);
    };

    document.getElementById('loadBtn').onclick=()=>{
      try{
        const data = JSON.parse(output.value);
        platforms = (Array.isArray(data) ? data : []);
        selected = null;
      }catch(e){
        alert('Invalid JSON');
      }
    };

    // Optional: push map live to server (requires server listener uncommented)
    // const socket = io();
    // document.getElementById('saveBtn').onclick=()=>{
    //   output.value=JSON.stringify(platforms,null,2);
    //   socket.emit('update map', platforms);
    // };
  </script>
  <script src="/socket.io/socket.io.js"></script>
</body>
</html>
