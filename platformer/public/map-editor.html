<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Map Editor</title>
  <style>
    body{margin:0;height:100vh;display:flex;font-family:"Segoe UI",sans-serif;background:#0f0f0f;color:#eee}
    #toolbox{width:220px;background:#1a1a1a;color:#eee;padding:12px;border-right:1px solid #333;display:flex;flex-direction:column;gap:8px}
    #toolbox h3{margin:0 0 8px;font-size:14px}
    #toolbox label{font-size:13px;display:flex;flex-direction:column;gap:4px}
    #toolbox select,#toolbox input{padding:4px;background:#111;color:#eee;border:1px solid #333;border-radius:4px}
    #toolbox button{background:#3b82f6;color:#fff;border:none;border-radius:6px;padding:6px;cursor:pointer;font-size:13px}
    #toolbox button:hover{background:#2563eb}
    #editorArea{flex:1;display:flex;flex-direction:column;background:#1a1a1a}
    #canvas{flex:1;background:#222;border-right:1px solid #333}
    #jsonPanel{width:400px;background:#121212;border-left:1px solid #333;display:flex;flex-direction:column}
    #jsonPanel h3{margin:0;padding:12px;font-size:14px;background:#1f1f1f;border-bottom:1px solid #333}
    #editorOutput{flex:1;width:100%;border:none;resize:none;padding:12px;font-family:monospace;font-size:13px;background:#0f0f0f;color:#eee;overflow:auto;white-space:pre}
    #copyBtn{background:#3b82f6;border:none;color:#fff;padding:8px;cursor:pointer;font-size:13px}
    #copyBtn:hover{background:#2563eb}
    #infoPanel{width:260px;background:#1a1a1a;color:#eee;padding:12px;border-left:1px solid #333;overflow-y:auto}
    #infoPanel h3{margin:0 0 8px;font-size:14px}
    #infoPanel ul{list-style:none;padding:0;margin:0}
    #infoPanel li{font-size:13px;margin:6px 0}
    #loading{position:fixed;top:0;left:0;right:0;bottom:0;background:#0f0f0f;color:#fff;display:flex;align-items:center;justify-content:center;font-size:20px;z-index:9999}
  </style>
</head>
<body>
  <div id="loading">Loading map editor...</div>

  <div id="toolbox">
    <h3>Tools</h3>
    <label>Material:
      <select id="materialSelect">
        <option value="normal">Normal</option>
        <option value="ice">Ice</option>
        <option value="lava">Lava</option>
        <option value="bounce">Bounce</option>
        <option value="sticky">Sticky</option>
      </select>
    </label>
    <label>Rotation:
      <input type="number" id="rotationInput" value="0" step="5">Â°
    </label>
    <button id="addBtn">Add Platform</button>
    <button id="deleteBtn">Delete Selected</button>
    <button id="saveBtn">Save JSON</button>
    <label>Load Map:
      <input type="file" id="loadFile" accept="application/json">
    </label>
  </div>

  <div id="editorArea">
    <canvas id="canvas"></canvas>
  </div>

  <div id="jsonPanel">
    <h3>JSON Output</h3>
    <textarea id="editorOutput" readonly></textarea>
    <button id="copyBtn">Copy JSON</button>
  </div>

  <div id="infoPanel">
    <h3>Instructions</h3>
    <ul>
      <li>Click a block to select it.</li>
      <li>Shift + Click to select multiple blocks.</li>
      <li>Drag handles to resize blocks.</li>
      <li>Drag rotation handle (blue circle) to rotate.</li>
      <li>Drag inside block to move it.</li>
      <li>Use arrow keys/WASD to scroll the camera.</li>
      <li>Use "Add Platform" to create new blocks.</li>
      <li>Use "Delete Selected" to remove blocks.</li>
      <li>Use "Save JSON" to export map data.</li>
      <li>Use "Load Map" to import a saved JSON file.</li>
      <li>Group selection: drag group handles to scale multiple blocks at once.</li>
    </ul>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const output = document.getElementById('editorOutput');
    const copyBtn = document.getElementById('copyBtn');
    const materialSelect = document.getElementById('materialSelect');
    const rotationInput = document.getElementById('rotationInput');
    const addBtn = document.getElementById('addBtn');
    const deleteBtn = document.getElementById('deleteBtn');
    const saveBtn = document.getElementById('saveBtn');
    const loadFile = document.getElementById('loadFile');

    const worldWidth = 4000;
    const worldHeight = 2000;
    let cameraX = 0;
    let cameraY = 0;

    let world = { platforms: [] };
    let selectedIndices = [];
    let dragHandle = null;
    let draggingPlatform = false;
    let rotatingPlatform = false;
    let dragOffsetX = 0;
    let dragOffsetY = 0;

    function resizeCanvas() {
      canvas.width = window.innerWidth - document.getElementById('jsonPanel').offsetWidth - document.getElementById('toolbox').offsetWidth - document.getElementById('infoPanel').offsetWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);

    function getHandles(p) {
      return [
        {x: p.x, y: p.y},
        {x: p.x + p.w, y: p.y},
        {x: p.x, y: p.y + p.h},
        {x: p.x + p.w, y: p.y + p.h}
      ];
    }

    function getGroupBounds() {
      const selected = selectedIndices.map(i => world.platforms[i]);
      if (selected.length === 0) return null;
      const minX = Math.min(...selected.map(p => p.x));
      const minY = Math.min(...selected.map(p => p.y));
      const maxX = Math.max(...selected.map(p => p.x + p.w));
      const maxY = Math.max(...selected.map(p => p.y + p.h));
      return { x:minX, y:minY, w:maxX-minX, h:maxY-minY };
    }

    function redraw() {
      ctx.fillStyle = '#222';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    
      // Floor
      ctx.fillStyle = '#444';
      ctx.fillRect(-cameraX, worldHeight - 40 - cameraY, worldWidth, 40);

      world.platforms.forEach((p, i) => {
        ctx.save();
        ctx.translate(p.x - cameraX + p.w/2, p.y - cameraY + p.h/2);
        ctx.rotate(p.rotation * Math.PI/180);
        ctx.fillStyle = p.material === 'ice' ? '#3b82f6'
                     : p.material === 'lava' ? '#ef4444'
                     : p.material === 'bounce' ? '#facc15'
                     : p.material === 'sticky' ? '#10b981'
                     : '#888';
        ctx.fillRect(-p.w/2, -p.h/2, p.w, p.h);
        ctx.restore();
      });

      // Highlight selections
      selectedIndices.forEach(i => {
        const p = world.platforms[i];
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.strokeRect(p.x - cameraX, p.y - cameraY, p.w, p.h);

    // Draw resize handles
        const handles = getHandles(p);
        ctx.fillStyle = '#fff';
        handles.forEach(h => ctx.fillRect(h.x - cameraX - 4, h.y - cameraY - 4, 8, 8));

        // Draw rotation handle (above block)
        const cx = p.x + p.w/2;
        const cy = p.y + p.h/2;
        const hx = cx;
        const hy = p.y - 40;
        ctx.fillStyle = '#0ff';
        ctx.beginPath();
        ctx.arc(hx - cameraX, hy - cameraY, 6, 0, Math.PI*2);
        ctx.fill();
        // store for hit detection
        p.rotationHandle = {x: hx, y: hy};
      });

      // Group box if multiple selected
      if (selectedIndices.length > 1) {
        const bounds = getGroupBounds();
        ctx.strokeStyle = '#0ff';
        ctx.strokeRect(bounds.x - cameraX, bounds.y - cameraY, bounds.w, bounds.h);

        // draw group handles
       const handles = [
          {x: bounds.x, y: bounds.y},
          {x: bounds.x + bounds.w, y: bounds.y},
          {x: bounds.x, y: bounds.y + bounds.h},
        {x: bounds.x + bounds.w, y: bounds.y + bounds.h}
        ];
        ctx.fillStyle = '#0ff';
        handles.forEach(h => ctx.fillRect(h.x - cameraX - 4, h.y - cameraY - 4, 8, 8));
      }

      output.value = JSON.stringify(world.platforms, null, 2);
    }


    addBtn.addEventListener('click', () => {
      const newPlat = {
        x: cameraX + 100, y: cameraY + 100, w: 200, h: 20,
                rotation: parseInt(rotationInput.value, 10) || 0,
        material: materialSelect.value
      };
      world.platforms.push(newPlat);
      selectedIndices = [world.platforms.length - 1];
    });

    deleteBtn.addEventListener('click', () => {
      if (selectedIndices.length > 0) {
        world.platforms = world.platforms.filter((_, i) => !selectedIndices.includes(i));
        selectedIndices = [];
      }
    });

    saveBtn.addEventListener('click', () => {
      output.value = JSON.stringify(world.platforms, null, 2);
    });

    copyBtn.addEventListener('click', () => {
      output.select();
      document.execCommand('copy');
      alert('JSON copied to clipboard!');
    });

    // Load map from file
    loadFile.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (evt) => {
        try {
          const data = JSON.parse(evt.target.result);
          if (Array.isArray(data)) {
            world.platforms = data;
          } else if (data.platforms) {
            world.platforms = data.platforms;
          } else {
            alert("Invalid map format");
            return;
          }
          selectedIndices = [];
        } catch (err) {
          alert("Error loading map: " + err.message);
        }
      };
      reader.readAsText(file);
    });

    // Mouse events for selection, dragging, scaling, rotation
  canvas.addEventListener('mousemove', (e) => {
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left + cameraX;
  const my = e.clientY - rect.top + cameraY;

  // Single block resize/rotate/drag
  if (dragHandle !== null && selectedIndices.length === 1) {
    const p = world.platforms[selectedIndices[0]];
    switch (dragHandle) {
      case 0: p.w = (p.x + p.w) - mx; p.h = (p.y + p.h) - my; p.x = mx; p.y = my; break;
      case 1: p.w = mx - p.x; p.h = (p.y + p.h) - my; p.y = my; break;
      case 2: p.w = (p.x + p.w) - mx; p.h = my - p.y; p.x = mx; break;
      case 3: p.w = mx - p.x; p.h = my - p.y; break;
    }
  } else if (rotatingPlatform && selectedIndices.length === 1) {
    const p = world.platforms[selectedIndices[0]];
    const cx = p.x + p.w/2;
    const cy = p.y + p.h/2;
    const angle = Math.atan2(my - cy, mx - cx) * 180/Math.PI;
    p.rotation = angle;
  } else if (draggingPlatform && selectedIndices.length === 1) {
    const p = world.platforms[selectedIndices[0]];
    p.x = mx - dragOffsetX;
    p.y = my - dragOffsetY;
  }

  // Group scaling
  if (dragHandle !== null && selectedIndices.length > 1) {
    const bounds = getGroupBounds();
    if (!bounds) return;
    let factorX = 1, factorY = 1;
    switch (dragHandle) {
      case 0: factorX = (bounds.x + bounds.w - mx) / bounds.w; factorY = (bounds.y + bounds.h - my) / bounds.h; break;
      case 1: factorX = (mx - bounds.x) / bounds.w; factorY = (bounds.y + bounds.h - my) / bounds.h; break;
      case 2: factorX = (bounds.x + bounds.w - mx) / bounds.w; factorY = (my - bounds.y) / bounds.h; break;
      case 3: factorX = (mx - bounds.x) / bounds.w; factorY = (my - bounds.y) / bounds.h; break;
    }
    const cx = bounds.x + bounds.w/2;
    const cy = bounds.y + bounds.h/2;
    selectedIndices.forEach(i => {
      const p = world.platforms[i];
      p.x = cx + (p.x - cx) * factorX;
      p.y = cy + (p.y - cy) * factorY;
      p.w *= factorX;
      p.h *= factorY;
    });
  }
});

canvas.addEventListener('mouseup', () => {
  dragHandle = null;
  draggingPlatform = false;
  rotatingPlatform = false;
});

    // Camera scrolling with arrow keys/WASD
    document.addEventListener('keydown', (e) => {
      const step = 50;
      if (e.key === 'ArrowLeft' || e.key === 'a') cameraX = Math.max(0, cameraX - step);
      if (e.key === 'ArrowRight' || e.key === 'd') cameraX = Math.min(worldWidth - canvas.width, cameraX + step);
      if (e.key === 'ArrowUp' || e.key === 'w') cameraY = Math.max(0, cameraY - step);
      if (e.key === 'ArrowDown' || e.key === 's') cameraY = Math.min(worldHeight - canvas.height, cameraY + step);
    });

    // Auto-update loop
    function gameLoop() {
      redraw();
      requestAnimationFrame(gameLoop);
    }

    // Initialize
    window.addEventListener('load', () => {
      document.getElementById('loading').style.display = 'none';
      resizeCanvas();
      gameLoop();
    });
  </script>
</body>
</html>
