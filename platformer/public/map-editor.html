<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Map Editor (Stable + Materials)</title>
  <style>
    body { margin:0; height:100vh; display:flex; font-family:"Segoe UI",sans-serif; background:#0f0f0f; color:#eee; }
    #toolbox { width:240px; background:#1a1a1a; padding:12px; border-right:1px solid #333; display:flex; flex-direction:column; gap:10px; }
    #toolbox h3 { margin:0 0 8px; font-size:15px; }
    #toolbox label { font-size:13px; display:flex; flex-direction:column; gap:4px; }
    #toolbox select, #toolbox input { padding:6px; background:#111; color:#eee; border:1px solid #333; border-radius:4px; }
    #toolbox button { background:#3b82f6; color:#fff; border:none; border-radius:6px; padding:8px; cursor:pointer; font-size:13px; }
    #toolbox button:hover { background:#2563eb; }
    #editorArea { flex:1; display:flex; flex-direction:column; background:#1a1a1a; }
    #canvas { flex:1; background:#222; }
    #jsonPanel { width:360px; background:#121212; border-left:1px solid #333; display:flex; flex-direction:column; }
    #jsonPanel h3 { margin:0; padding:12px; font-size:14px; background:#1f1f1f; border-bottom:1px solid #333; }
    #editorOutput { flex:1; width:100%; border:none; resize:none; padding:12px; font-family:monospace; font-size:13px; background:#0f0f0f; color:#eee; overflow:auto; white-space:pre; }
    #copyBtn { background:#3b82f6; border:none; color:#fff; padding:8px; cursor:pointer; font-size:13px; }
    #copyBtn:hover { background:#2563eb; }
    #infoPanel { width:260px; background:#1a1a1a; padding:12px; border-left:1px solid #333; overflow-y:auto; }
    #infoPanel h3 { margin:0 0 8px; font-size:14px; }
    #infoPanel ul { list-style:none; padding:0; margin:0; }
    #infoPanel li { font-size:13px; margin:6px 0; }
    #loading { position:fixed; top:0; left:0; right:0; bottom:0; background:#0f0f0f; color:#fff; display:flex; align-items:center; justify-content:center; font-size:20px; z-index:9999; }
  </style>
</head>
<body>
  <div id="loading">Loading map editor...</div>

  <div id="toolbox">
    <h3>Tools</h3>
    <label>Material:
      <select id="materialSelect">
        <option value="normal">Normal</option>
        <option value="ice">Ice</option>
        <option value="lava">Lava</option>
        <option value="bounce">Bounce</option>
        <option value="sticky">Sticky</option>
      </select>
    </label>
    <label>Rotation:
      <input type="number" id="rotationInput" value="0" step="5">Â°
    </label>
    <button id="addBtn">Add Platform</button>
    <button id="deleteBtn">Delete Selected</button>
    <button id="saveBtn">Save JSON</button>
    <label>Load Map:
      <input type="file" id="loadFile" accept="application/json">
    </label>
  </div>

  <div id="editorArea">
    <canvas id="canvas"></canvas>
  </div>

  <div id="jsonPanel">
    <h3>JSON Output</h3>
    <textarea id="editorOutput" readonly></textarea>
    <button id="copyBtn">Copy JSON</button>
  </div>

  <div id="infoPanel">
    <h3>Instructions</h3>
    <ul>
      <li>Click a block to select it.</li>
      <li>Drag inside block to move it.</li>
      <li>Drag corner handles to resize.</li>
      <li>Drag cyan circle above block to rotate.</li>
      <li>Use arrow keys/WASD to scroll camera.</li>
      <li>Choose material & rotation before adding new blocks.</li>
    </ul>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const output = document.getElementById('editorOutput');
    const addBtn = document.getElementById('addBtn');
    const deleteBtn = document.getElementById('deleteBtn');
    const saveBtn = document.getElementById('saveBtn');
    const copyBtn = document.getElementById('copyBtn');
    const loadFile = document.getElementById('loadFile');
    const materialSelect = document.getElementById('materialSelect');
    const rotationInput = document.getElementById('rotationInput');

    const worldWidth = 4000, worldHeight = 2000;
    let cameraX = 0, cameraY = 0;
    let world = { platforms: [] };
    let selectedIndex = null;
    let dragHandle = null, draggingPlatform = false, rotatingPlatform = false;
    let dragOffsetX = 0, dragOffsetY = 0;

    function resizeCanvas() {
      canvas.width = window.innerWidth - document.getElementById('jsonPanel').offsetWidth - document.getElementById('toolbox').offsetWidth - document.getElementById('infoPanel').offsetWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);

    function getHandles(p) {
      return [
        {x: p.x, y: p.y},
        {x: p.x + p.w, y: p.y},
        {x: p.x, y: p.y + p.h},
        {x: p.x + p.w, y: p.y + p.h}
      ];
    }

    function redraw() {
      ctx.fillStyle = '#222';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      world.platforms.forEach((p, i) => {
        ctx.save();
        ctx.translate(p.x - cameraX + p.w/2, p.y - cameraY + p.h/2);
        ctx.rotate(p.rotation * Math.PI/180);
        ctx.fillStyle = p.material === 'ice' ? '#3b82f6'
                     : p.material === 'lava' ? '#ef4444'
                     : p.material === 'bounce' ? '#facc15'
                     : p.material === 'sticky' ? '#10b981'
                     : '#888';
        ctx.fillRect(-p.w/2, -p.h/2, p.w, p.h);
        ctx.restore();

        if (i === selectedIndex) {
          ctx.strokeStyle = '#fff';
          ctx.strokeRect(p.x - cameraX, p.y - cameraY, p.w, p.h);
          const handles = getHandles(p);
          ctx.fillStyle = '#fff';
          handles.forEach(h => ctx.fillRect(h.x - cameraX - 4, h.y - cameraY - 4, 8, 8));
          const cx = p.x + p.w/2;
          const hy = p.y - 40;
          ctx.fillStyle = '#0ff';
          ctx.beginPath();
          ctx.arc(cx - cameraX, hy - cameraY, 6, 0, Math.PI*2);
          ctx.fill();
          p.rotationHandle = {x: cx, y: hy};
        }
      });

      output.value = JSON.stringify(world.platforms, null, 2);
    }

    addBtn.addEventListener('click', () => {
      const newPlat = {
        x: cameraX+100, y: cameraY+100, w:200, h:20,
        rotation: parseInt(rotationInput.value, 10) || 0,
        material: materialSelect.value
      };
      world.platforms.push(newPlat);
      selectedIndex = world.platforms.length - 1;
    });

    deleteBtn.addEventListener('click', () => {
      if (selectedIndex !== null) {
        world.platforms.splice(selectedIndex, 1);
        selectedIndex = null;
      }
    });

    saveBtn.addEventListener('click', () => {
      output.value = JSON.stringify(world.platforms, null, 2);
    });

    copyBtn.addEventListener('click', () => {
      output.select();
      document.execCommand('copy');
      alert('JSON copied!');
    });

      loadFile.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (evt) => {
        try {
          const data = JSON.parse(evt.target.result);
          world.platforms = Array.isArray(data) ? data : data.platforms || [];
          selectedIndex = null;
        } catch (err) { alert("Error loading map"); }
      };
      reader.readAsText(file);
    });

    // Mouse events
        canvas.addEventListener('mousedown', (e) => {
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left + cameraX;
        const my = e.clientY - rect.top + cameraY;

        // If a block is already selected, check its handles/rotation/drag
        if (selectedIndex !== null) {
            const p = world.platforms[selectedIndex];
            const handles = getHandles(p);
            const hit = handles.findIndex(h => Math.abs(mx - h.x) < 6 && Math.abs(my - h.y) < 6);
            if (hit !== -1) { dragHandle = hit; return; }
            if (p.rotationHandle && Math.hypot(mx - p.rotationHandle.x, my - p.rotationHandle.y) < 10) {
                rotatingPlatform = true; return;
            }
            if (mx >= p.x && mx <= p.x + p.w && my >= p.y && my <= p.y + p.h) {
                draggingPlatform = true;
                dragOffsetX = mx - p.x;
                dragOffsetY = my - p.y;
                return;
            }
        }

        // Selection logic: find any block under cursor
        const found = world.platforms.findIndex(p =>
            mx >= p.x && mx <= p.x + p.w &&
            my >= p.y && my <= p.y + p.h
        );

        if (found !== -1) {
            selectedIndex = found;   // reselect clicked block
        } else {
            selectedIndex = null;    // clear selection if clicked empty space
        }
    });


    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left + cameraX;
      const my = e.clientY - rect.top + cameraY;
      if (dragHandle !== null && selectedIndex !== null) {
        const p = world.platforms[selectedIndex];
        switch (dragHandle) {
          case 0: p.w = (p.x+p.w)-mx; p.h = (p.y+p.h)-my; p.x = mx; p.y = my; break;
          case 1: p.w = mx-p.x; p.h = (p.y+p.h)-my; p.y = my; break;
          case 2: p.w = (p.x+p.w)-mx; p.h = my-p.y; p.x = mx; break;
          case 3: p.w = mx-p.x; p.h = my-p.y; break;
        }
      } else if (rotatingPlatform && selectedIndex !== null) {
        const p = world.platforms[selectedIndex];
        const cx = p.x + p.w/2;
        const cy = p.y + p.h/2;
        const angle = Math.atan2(my - cy, mx - cx) * 180/Math.PI;
        p.rotation = Math.round(angle * 100) / 100;  // round to hundredths
      } else if (draggingPlatform && selectedIndex !== null) {
        const p = world.platforms[selectedIndex];
        p.x = mx - dragOffsetX;
        p.y = my - dragOffsetY;
      }
    });

    canvas.addEventListener('mouseup', () => {
      dragHandle = null;
      draggingPlatform = false;
      rotatingPlatform = false;
    });

    // Camera scrolling
    document.addEventListener('keydown', (e) => {
      const step = 50;
      if (e.key === 'ArrowLeft' || e.key === 'a') cameraX = Math.max(0, cameraX - step);
      if (e.key === 'ArrowRight' || e.key === 'd') cameraX = Math.min(worldWidth - canvas.width, cameraX + step);
      if (e.key === 'ArrowUp' || e.key === 'w') cameraY = Math.max(0, cameraY - step);
      if (e.key === 'ArrowDown' || e.key === 's') cameraY = Math.min(worldHeight - canvas.height, cameraY + step);
    });

    // Auto-update loop
    function gameLoop() {
      redraw();
      requestAnimationFrame(gameLoop);
    }

    // Initialize
    window.addEventListener('load', () => {
      document.getElementById('loading').style.display = 'none';
      resizeCanvas();
      gameLoop();
    });
  </script>
</body>
</html>
