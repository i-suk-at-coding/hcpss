<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Map Editor</title>
  <style>
    body { margin:0; display:flex; flex-direction:column; height:100vh; }
    #editorArea { flex:1; display:flex; flex-direction:column; background:#1a1a1a; }
    #canvas { flex:1; background:#222; }
    #jsonPanel { width:360px; background:#121212; border-left:1px solid #333; display:flex; flex-direction:column; }
    #jsonPanel h3 { margin:0; padding:12px; font-size:14px; background:#1f1f1f; border-bottom:1px solid #333; }
    #editorOutput { flex:1; width:100%; border:none; resize:none; padding:12px; font-family:monospace; font-size:13px; background:#0f0f0f; color:#eee; overflow:auto; white-space:pre; }
    #copyBtn { background:#3b82f6; border:none; color:#fff; padding:8px; cursor:pointer; font-size:13px; }
    #copyBtn:hover { background:#2563eb; }
    #infoPanel { width:260px; background:#1a1a1a; padding:12px; border-left:1px solid #333; overflow-y:auto; }
    #infoPanel h3 { margin:0 0 8px; font-size:14px; }
    #infoPanel ul { list-style:none; padding:0; margin:0; }
    #infoPanel li { font-size:13px; margin:6px 0; }
    #toolbar {position:fixed;top:0;left:0;right:0;height:40px;display:flex;flex-direction:row;align-items:center;gap:8px;padding:6px;background:#333;color:#fff;z-index:1000;}
    #toolbar button,#toolbar select,#toolbar input {padding:4px 8px;font-size:14px;}
    #canvas {position:absolute;top:40px;left:0;}
    #jsonPanel {position:absolute;top:40px;right:0;width:300px;height:calc(100% - 40px);background:#111;color:#fff;display:flex;flex-direction:column;}
    #editorOutput,#jsonInput {flex:1;margin:4px;font-size:12px;background:#222;color:#0ff;}
  </style>
</head>
<body>
  <!-- Toolbar at the top -->
  <div id="toolbar">
    <button id="addBtn">Add</button>
    <button id="deleteBtn">Delete</button>
    <button id="saveBtn">Save</button>
    <button id="copyBtn">Copy</button>
    <input type="file" id="loadFile" />
    <select id="materialSelect">
      <option value="normal">Normal</option>
      <option value="ice">Ice</option>
      <option value="lava">Lava</option>
      <option value="bounce">Bounce</option>
      <option value="sticky">Sticky</option>
    </select>
    <button id="helpBtn">Help</button>
  </div>

  <!-- Canvas area -->
  <canvas id="canvas"></canvas>

  <!-- JSON panel -->
  <div id="jsonPanel">
    <textarea id="editorOutput"></textarea>
    <textarea id="jsonInput" placeholder="Paste JSON here"></textarea>
    <button id="loadTextBtn">Load from Text</button>
  </div>
<script>
  // --- Toolbar Help ---
  document.getElementById('helpBtn').addEventListener('click', () => {
    alert("Controls:\n- Arrow keys/WASD: Move camera\n- Click+Drag: Move block\n- Drag box: Select multiple\n- Corner handles: Scale block\n- Rotation handle above block: Rotate\n- Toolbar buttons: Add/Delete/Save/Copy/Load\n- Set Spawn: Click to place spawn point\n- Add Curve: Click points, press Enter to finalize\n- Drag curve handles: reshape curve");
  });

  // --- Canvas ---
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  // --- UI Elements ---
  const addBtn = document.getElementById('addBtn');
  const deleteBtn = document.getElementById('deleteBtn');
  const saveBtn = document.getElementById('saveBtn');
  const copyBtn = document.getElementById('copyBtn');
  const materialSelect = document.getElementById('materialSelect');
  const output = document.getElementById('editorOutput');

  // --- Add Spawn Button ---
  const spawnBtn = document.createElement('button');
  spawnBtn.textContent = "Set Spawn";
  document.getElementById('toolbar').appendChild(spawnBtn);

  // --- World State ---
  const worldWidth = 4000, worldHeight = 2000;
  let cameraX = 0, cameraY = 0;
  let world = { platforms: [], spawn: { x: 100, y: 100 } };
  let selectedIndices = [];

  // --- Interaction State ---
  let dragOffsets = {};
  let draggingPlatform = false;
  let rotatingPlatform = false;
  let scalingPlatform = false;
  let activeHandle = null;
  let startMouse = null;
  let startPlatform = null;
  let startRotation = 0;
  let selectingBox = false;
  let selectStartX = 0, selectStartY = 0;
  let selectCurrentX = 0, selectCurrentY = 0;
  let settingSpawn = false;

  // --- Resize ---
  function resizeCanvas() {
    const jsonPanel = document.getElementById('jsonPanel');
    const panelWidth = jsonPanel ? jsonPanel.offsetWidth : 0;
    canvas.width = window.innerWidth - panelWidth;
    canvas.height = window.innerHeight;
  }
  window.addEventListener('resize', resizeCanvas);

  // --- Helpers ---
  function getHandles(p) {
    return [
      { x: p.x, y: p.y },
      { x: p.x + p.w, y: p.y },
      { x: p.x, y: p.y + p.h },
      { x: p.x + p.w, y: p.y + p.h }
    ];
  }

  function worldToLiteral(world) {
  // stringify with indentation
  let str = JSON.stringify(world, null, 2);
  // remove quotes around simple keys
  str = str.replace(/"(\w+)":/g, '$1:');
  // wrap in const WORLD = { … };
  return `const WORLD = ${str}`;
}


  // --- Redraw ---
  function redraw() {
    ctx.fillStyle = '#222';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Platforms
    world.platforms.forEach((p, i) => {
      ctx.fillStyle =
        p.material==='ice' ? '#3b82f6' :
        p.material==='lava' ? '#ef4444' :
        p.material==='bounce' ? '#facc15' :
        p.material==='sticky' ? '#10b981' : '#888';

      if (p.type === "curve" && Array.isArray(p.points)) {
        ctx.beginPath();
        ctx.moveTo(p.points[0].x - cameraX, p.points[0].y - cameraY);
        for (let j=1; j<p.points.length; j++) {
          ctx.lineTo(p.points[j].x - cameraX, p.points[j].y - cameraY);
        }
        ctx.closePath();
        ctx.fill();

        if (selectedIndices.includes(i)) {
          ctx.fillStyle = '#fff';
          p.points.forEach(pt => {
            ctx.fillRect(pt.x - cameraX - 4, pt.y - cameraY - 4, 8, 8);
          });
        }
      } else {
        ctx.save();
        ctx.translate(p.x - cameraX + p.w/2, p.y - cameraY + p.h/2);
        ctx.rotate((p.rotation||0) * Math.PI/180);
        ctx.fillRect(-p.w/2, -p.h/2, p.w, p.h);
        ctx.restore();

        if (selectedIndices.includes(i)) {
          ctx.strokeStyle = '#fff';
          ctx.strokeRect(p.x - cameraX, p.y - cameraY, p.w, p.h);

          ctx.fillStyle = '#fff';
          getHandles(p).forEach(h => ctx.fillRect(h.x - cameraX - 4, h.y - cameraY - 4, 8, 8));

          const cx = p.x + p.w/2;
          const hy = p.y - 40;
          ctx.fillStyle = '#0ff';
          ctx.beginPath();
          ctx.arc(cx - cameraX, hy - cameraY, 6, 0, Math.PI*2);
          ctx.fill();
          p.rotationHandle = { x: cx, y: hy };
        }
      }
    });

    // Spawn point
    if (world.spawn) {
      ctx.fillStyle = '#0f0';
      ctx.beginPath();
      ctx.arc(world.spawn.x - cameraX, world.spawn.y - cameraY, 12, 0, Math.PI*2);
      ctx.fill();
      ctx.strokeStyle = '#fff';
      ctx.stroke();
    }

    // JSON output
    output.value = worldToLiteral(world);
  }

  // --- Toolbar Actions ---
  addBtn.addEventListener('click', () => {
    world.platforms.push({ type:"rect", x: cameraX+100, y: cameraY+100, w:200, h:20, rotation:0, material:materialSelect.value });
    selectedIndices = [world.platforms.length-1];
    redraw();
  });
  deleteBtn.addEventListener('click', () => {
    world.platforms = world.platforms.filter((_,i)=>!selectedIndices.includes(i));
    selectedIndices = [];
    redraw();
  });
  saveBtn.addEventListener('click', () => { output.value = worldToLiteral(world); });
  copyBtn.addEventListener('click', () => { output.select(); document.execCommand('copy'); alert('JSON copied!'); });
  spawnBtn.addEventListener('click', () => { settingSpawn = true; });


/// --- Bezier Curve Button ---
const curveBtn = document.createElement('button');
curveBtn.textContent = "Add Curve";
document.getElementById('toolbar').appendChild(curveBtn);

let addingCurve = false;
let curvePoints = [];

curveBtn.addEventListener('click', () => {
  addingCurve = true;
  curvePoints = [];
});

// --- Bezier Helper ---
function bezierToPolygon(p0, p1, p2, steps=20) {
  const pts = [];
  for (let t = 0; t <= 1; t += 1/steps) {
    const x = (1-t)*(1-t)*p0.x + 2*(1-t)*t*p1.x + t*t*p2.x;
    const y = (1-t)*(1-t)*p0.y + 2*(1-t)*t*p1.y + t*t*p2.y;
    pts.push({x,y});
  }
  return pts;
}

// --- Mouse events ---
canvas.addEventListener('mousedown', e => {
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left + cameraX;
  const my = e.clientY - rect.top + cameraY;

  // Curve creation
  if (addingCurve) {
    curvePoints.push({x:mx, y:my});

    if (curvePoints.length === 3) {
      const [p0, p1, p2] = curvePoints;
      const curve = bezierToPolygon(p0, p1, p2, 20);
      world.platforms.push({
        type: "curve",
        material: materialSelect.value,
        points: curve
      });
      selectedIndices = [world.platforms.length-1];
      addingCurve = false;
      curvePoints = [];
      redraw();
      return; // exit only after curve is complete
    }
    // don’t return here if only 1–2 points clicked
  }

  // Curve point dragging
  if (selectedIndices.length === 1) {
    const p = world.platforms[selectedIndices[0]];
    if (p.type === "curve") {
      const foundHandle = p.points.findIndex(pt => Math.hypot(mx-pt.x,my-pt.y) < 8);
      if (foundHandle !== -1) {
        draggingPlatform = true;
        activeHandle = foundHandle;
        startMouse = {mx,my};
        startPlatform = JSON.parse(JSON.stringify(p));
        return;
      }
    }
  }

  // Normal selection (rectangles)
  const found = world.platforms.findIndex(p =>
    p.type==="rect" && mx>=p.x && mx<=p.x+p.w && my>=p.y && my<=p.y+p.h
  );
  if (found === -1) {
    selectingBox = true;
    selectStartX = mx; selectStartY = my;
    selectCurrentX = mx; selectCurrentY = my;
    selectedIndices = [];
  } else {
    if (!selectedIndices.includes(found)) selectedIndices = [found];
    dragOffsets = {};
    selectedIndices.forEach(i => {
      const p = world.platforms[i];
      dragOffsets[i] = {dx: mx - p.x, dy: my - p.y};
    });
    draggingPlatform = true;
  }
});

canvas.addEventListener('mousemove', e => {
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left + cameraX;
  const my = e.clientY - rect.top + cameraY;

  // Curve point dragging
  if (draggingPlatform && selectedIndices.length === 1) {
    const p = world.platforms[selectedIndices[0]];
    if (p.type === "curve" && activeHandle !== null) {
      const dx = mx - startMouse.mx;
      const dy = my - startMouse.my;
      p.points[activeHandle].x = startPlatform.points[activeHandle].x + dx;
      p.points[activeHandle].y = startPlatform.points[activeHandle].y + dy;
      return;
    }
  }

  // Rectangle dragging
  if (draggingPlatform) {
    selectedIndices.forEach(i => {
      const plat = world.platforms[i];
      plat.x = mx - dragOffsets[i].dx;
      plat.y = my - dragOffsets[i].dy;
    });
  }

  // Rotation
  if (rotatingPlatform && selectedIndices.length === 1) {
    const p = world.platforms[selectedIndices[0]];
    const cx = p.x + p.w/2, cy = p.y + p.h/2;
    const angle = Math.atan2(my - cy, mx - cx) * 180 / Math.PI;
    p.rotation = angle;
    return;
  }

  // Scaling
  if (scalingPlatform && selectedIndices.length === 1) {
    const p = world.platforms[selectedIndices[0]];
    const dx = mx - startMouse.mx, dy = my - startMouse.my;
    switch (activeHandle) {
      case 0: p.x = startPlatform.x + dx; p.y = startPlatform.y + dy; p.w = startPlatform.w - dx; p.h = startPlatform.h - dy; break;
      case 1: p.y = startPlatform.y + dy; p.w = startPlatform.w + dx; p.h = startPlatform.h - dy; break;
      case 2: p.x = startPlatform.x + dx; p.w = startPlatform.w - dx; p.h = startPlatform.h + dy; break;
      case 3: p.w = startPlatform.w + dx; p.h = startPlatform.h + dy; break;
    }
    return;
  }
});

canvas.addEventListener('mouseup', () => {
  rotatingPlatform = false;
  scalingPlatform = false;
  draggingPlatform = false;
  selectingBox = false;
  activeHandle = null;
});

  // --- Camera ---
  document.addEventListener('keydown', e => {
    const step=50;
    if(e.key==='ArrowLeft'||e.key==='a') cameraX=Math.max(0,cameraX-step);
    if(e.key==='ArrowRight'||e.key==='d') cameraX=Math.min(worldWidth-canvas.width,cameraX+step);
    if(e.key==='ArrowUp'||e.key==='w') cameraY=Math.max(0,cameraY-step);
    if(e.key==='ArrowDown'||e.key==='s') cameraY=Math.min(worldHeight-canvas.height,cameraY+step);

    // Finalize curve with Enter
    if(addingCurve && e.key==='Enter' && curvePoints.length>=3){
      world.platforms.push({ type:"curve", material:materialSelect.value, points:curvePoints });
      addingCurve=false;
      selectedIndices=[world.platforms.length-1];
      curvePoints=[];
    }
  });

  // --- Loop ---
  function gameLoop() {
    redraw();
    requestAnimationFrame(gameLoop);
  }

  window.addEventListener('load', () => {
    resizeCanvas();
    gameLoop();
  });
</script>
</body>
</html>
