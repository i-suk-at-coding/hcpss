<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Map Editor (Stable + Materials)</title>
  <style>
    body { margin:0; height:100vh; display:flex; font-family:"Segoe UI",sans-serif; background:#0f0f0f; color:#eee; }
    #toolbox { width:240px; background:#1a1a1a; padding:12px; border-right:1px solid #333; display:flex; flex-direction:column; gap:10px; }
    #toolbox h3 { margin:0 0 8px; font-size:15px; }
    #toolbox label { font-size:13px; display:flex; flex-direction:column; gap:4px; }
    #toolbox select, #toolbox input { padding:6px; background:#111; color:#eee; border:1px solid #333; border-radius:4px; }
    #toolbox button { background:#3b82f6; color:#fff; border:none; border-radius:6px; padding:8px; cursor:pointer; font-size:13px; }
    #toolbox button:hover { background:#2563eb; }
    #editorArea { flex:1; display:flex; flex-direction:column; background:#1a1a1a; }
    #canvas { flex:1; background:#222; }
    #jsonPanel { width:360px; background:#121212; border-left:1px solid #333; display:flex; flex-direction:column; }
    #jsonPanel h3 { margin:0; padding:12px; font-size:14px; background:#1f1f1f; border-bottom:1px solid #333; }
    #editorOutput { flex:1; width:100%; border:none; resize:none; padding:12px; font-family:monospace; font-size:13px; background:#0f0f0f; color:#eee; overflow:auto; white-space:pre; }
    #copyBtn { background:#3b82f6; border:none; color:#fff; padding:8px; cursor:pointer; font-size:13px; }
    #copyBtn:hover { background:#2563eb; }
    #infoPanel { width:260px; background:#1a1a1a; padding:12px; border-left:1px solid #333; overflow-y:auto; }
    #infoPanel h3 { margin:0 0 8px; font-size:14px; }
    #infoPanel ul { list-style:none; padding:0; margin:0; }
    #infoPanel li { font-size:13px; margin:6px 0; }
    #loading { position:fixed; top:0; left:0; right:0; bottom:0; background:#0f0f0f; color:#fff; display:flex; align-items:center; justify-content:center; font-size:20px; z-index:9999; }
    #toolbar {display:flex;gap:8px;padding:6px;background:#333;color:#fff;align-items:center;}
    #toolbar button,#toolbar select,#toolbar input {padding:4px 8px;font-size:14px;}
    #jsonPanel {position:absolute;top:50px;right:0;width:300px;height:calc(100% - 50px);background:#111;color:#fff;display:flex;flex-direction:column;}
    #editorOutput,#jsonInput {flex:1;margin:4px;font-size:12px;background:#222;color:#0ff;}
    #loading {position:fixed;top:0;left:0;width:100%;height:100%;background:#222;color:#fff;display:flex;align-items:center;justify-content:center;font-size:2em;z-index:9999;}

  </style>
</head>
<body>
  <div id="loading">Loading map editor...</div>

  <body>
  <!-- Toolbar at the top -->
  <div id="toolbar">
    <button id="addBtn">Add</button>
    <button id="deleteBtn">Delete</button>
    <button id="saveBtn">Save</button>
    <button id="copyBtn">Copy</button>
    <input type="file" id="loadFile" />
    <select id="materialSelect">
      <option value="normal">Normal</option>
      <option value="ice">Ice</option>
      <option value="lava">Lava</option>
      <option value="bounce">Bounce</option>
      <option value="sticky">Sticky</option>
    </select>
    <button id="helpBtn">Help</button>
  </div>

  <!-- Canvas area -->
  <canvas id="canvas"></canvas>

  <!-- JSON panel -->
  <div id="jsonPanel">
    <textarea id="editorOutput"></textarea>
    <textarea id="jsonInput" placeholder="Paste JSON here"></textarea>
    <button id="loadTextBtn">Load from Text</button>
  </div>

  <!-- Loading overlay -->
  <div id="loading">Loading...</div>
<script>
  document.getElementById('helpBtn').addEventListener('click', () => {
      alert("Controls:\n- Arrow keys/WASD: Move camera\n- Click+Drag: Move block\n- Drag box: Select multiple\n- Rotation handle above block: Rotate\n- Toolbar buttons: Add/Delete/Save/Copy/Load");
  });

  // --- World and camera state ---
  const worldWidth = 4000, worldHeight = 2000;
  let cameraX = 0, cameraY = 0;
  let world = { platforms: [] };
  let selectedIndices = [];

  // --- Dragging state ---
  let dragHandle = null;
  let draggingPlatform = false;
  let rotatingPlatform = false;
  let dragOffsetX = 0, dragOffsetY = 0;

  // --- Canvas resize ---
  function resizeCanvas() {
    canvas.width =
      window.innerWidth -
      document.getElementById('jsonPanel').offsetWidth -
      document.getElementById('toolbox').offsetWidth -
      document.getElementById('infoPanel').offsetWidth;
    canvas.height = window.innerHeight;
  }
  window.addEventListener('resize', resizeCanvas);

  // --- Helpers ---
  function getHandles(p) {
    return [
      { x: p.x, y: p.y },
      { x: p.x + p.w, y: p.y },
      { x: p.x, y: p.y + p.h },
      { x: p.x + p.w, y: p.y + p.h }
    ];
  }

  function getGroupBounds() {
    const selected = selectedIndices.map(i => world.platforms[i]);
    const minX = Math.min(...selected.map(p => p.x));
    const minY = Math.min(...selected.map(p => p.y));
    const maxX = Math.max(...selected.map(p => p.x + p.w));
    const maxY = Math.max(...selected.map(p => p.y + p.h));
    return { x: minX, y: minY, w: maxX - minX, h: maxY - minY };
  }

  // --- Redraw everything ---
  function redraw() {
    ctx.fillStyle = '#222';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Floor
    ctx.fillStyle = '#444';
    ctx.fillRect(-cameraX, worldHeight - 40 - cameraY, worldWidth, 40);

    // Platforms
    world.platforms.forEach((p, i) => {
      ctx.save();
      ctx.translate(p.x - cameraX + p.w / 2, p.y - cameraY + p.h / 2);
      ctx.rotate((p.rotation * Math.PI) / 180);
      ctx.fillStyle =
        p.material === 'ice'    ? '#3b82f6' :
        p.material === 'lava'   ? '#ef4444' :
        p.material === 'bounce' ? '#facc15' :
        p.material === 'sticky' ? '#10b981' :
                                  '#888';
      ctx.fillRect(-p.w / 2, -p.h / 2, p.w, p.h);
      ctx.restore();

      // Selection handles
      if (selectedIndices.includes(i)) {
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.strokeRect(p.x - cameraX, p.y - cameraY, p.w, p.h);

        // Corner handles
        ctx.fillStyle = '#fff';
        getHandles(p).forEach(h =>
          ctx.fillRect(h.x - cameraX - 4, h.y - cameraY - 4, 8, 8)
        );

        // Rotation handle
        const cx = p.x + p.w / 2;
        const hy = p.y - 40;
        ctx.fillStyle = '#0ff';
        ctx.beginPath();
        ctx.arc(cx - cameraX, hy - cameraY, 6, 0, Math.PI * 2);
        ctx.fill();
        p.rotationHandle = { x: cx, y: hy };
      }
    });

    // Group box
    if (selectedIndices.length > 1) {
      const bounds = getGroupBounds();
      ctx.strokeStyle = '#0ff';
      ctx.strokeRect(bounds.x - cameraX, bounds.y - cameraY, bounds.w, bounds.h);

      ctx.fillStyle = '#0ff';
      [
        { x: bounds.x, y: bounds.y },
        { x: bounds.x + bounds.w, y: bounds.y },
        { x: bounds.x, y: bounds.y + bounds.h },
        { x: bounds.x + bounds.w, y: bounds.y + bounds.h }
      ].forEach(h =>
        ctx.fillRect(h.x - cameraX - 4, h.y - cameraY - 4, 8, 8)
      );
    }

    // Marquee selection
    if (selectingBox) {
      const x = Math.min(selectStartX, selectCurrentX) - cameraX;
      const y = Math.min(selectStartY, selectCurrentY) - cameraY;
      const w = Math.abs(selectCurrentX - selectStartX);
      const h = Math.abs(selectCurrentY - selectStartY);
      ctx.strokeStyle = '#0ff';
      ctx.lineWidth = 1;
      ctx.strokeRect(x, y, w, h);
      ctx.fillStyle = 'rgba(0,255,255,0.2)';
      ctx.fillRect(x, y, w, h);
    }

    // Compact JSON output
    output.value = world.platforms
      .map(p => JSON.stringify({
        x: p.x, y: p.y, w: p.w, h: p.h,
        rotation: p.rotation, material: p.material
      }))
      .join('\n');
  }

  // --- Buttons ---
  addBtn.addEventListener('click', () => {
    world.platforms.push({
      x: cameraX + 100,
      y: cameraY + 100,
      w: 200,
      h: 20,
      rotation: 0,
      material: materialSelect.value
    });
    selectedIndices = [world.platforms.length - 1];
  });

  deleteBtn.addEventListener('click', () => {
    world.platforms = world.platforms.filter((_, i) => !selectedIndices.includes(i));
    selectedIndices = [];
  });

  saveBtn.addEventListener('click', () => {
    output.value = world.platforms.map(p => JSON.stringify(p)).join('\n');
  });

  copyBtn.addEventListener('click', () => {
    output.select();
    document.execCommand('copy');
    alert('JSON copied!');
  });

  loadFile.addEventListener('change', e => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = evt => {
      try {
        const data = JSON.parse(evt.target.result);
        world.platforms = Array.isArray(data) ? data : data.platforms || [];
        selectedIndices = [];
      } catch {
        alert('Error loading map');
      }
    };
    reader.readAsText(file);
  });

  // --- Load from text ---
  loadTextBtn.addEventListener('click', () => {
    try {
      const raw = jsonInput.value.trim();
      let parsed;

      if (raw.startsWith('[') && raw.endsWith(']')) {
        parsed = JSON.parse(raw);
      } else {
        const lines = raw.split('\n')
          .map(l => l.trim())
          .filter(Boolean)
          .map(l => l.replace(/,?\s*$/, ''));
        parsed = JSON.parse(`[${lines.join(',')}]`);
      }

      if (!Array.isArray(parsed)) throw new Error('Expected an array');

      world.platforms = parsed.map(p => ({
        x: Number(p.x), y: Number(p.y),
        w: Number(p.w), h: Number(p.h),
        rotation: Number(p.rotation),
        material: String(p.material)
      }));
      selectedIndices = [];
      redraw();
    } catch (err) {
      alert(`Invalid JSON text: ${err.message}`);
    }
  });

  // --- Mouse events ---
  let selectingBox = false;
  let selectStartX = 0, selectStartY = 0;
  let selectCurrentX = 0, selectCurrentY = 0;

  canvas.addEventListener('mousedown', e => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left + cameraX;
    const my = e.clientY - rect.top + cameraY;

    const found = world.platforms.findIndex(
      p => mx >= p.x && mx <= p.x + p.w && my >= p.y && my <= p.y + p.h
    );

    if (found === -1) {
      selectingBox = true;
      selectStartX = mx; selectStartY = my;
      selectCurrentX = mx; selectCurrentY = my;
      selectedIndices = [];
    } else {
      selectedIndices = [found];
      const p = world.platforms[found];
      draggingPlatform = true;
      dragOffsetX = mx - p.x;
      dragOffsetY = my - p.y;
    }
  });

  canvas.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left + cameraX;
    const my = e.clientY - rect.top + cameraY;

    if (selectingBox) {
      selectCurrentX = mx;
      selectCurrentY = my;
      return;
    }
<script>
  // --- World and camera state ---
  const worldWidth = 4000, worldHeight = 2000;
  let cameraX = 0, cameraY = 0;
  let world = { platforms: [] };
  let selectedIndices = [];

  // --- Dragging state ---
  let dragHandle = null;
  let draggingPlatform = false;
  let rotatingPlatform = false;
  let dragOffsetX = 0, dragOffsetY = 0;

  // --- Canvas resize ---
  function resizeCanvas() {
    canvas.width =
      window.innerWidth -
      document.getElementById('jsonPanel').offsetWidth -
      document.getElementById('toolbox').offsetWidth -
      document.getElementById('infoPanel').offsetWidth;
    canvas.height = window.innerHeight;
  }
  window.addEventListener('resize', resizeCanvas);

  // --- Helpers ---
  function getHandles(p) {
    return [
      { x: p.x, y: p.y },
      { x: p.x + p.w, y: p.y },
      { x: p.x, y: p.y + p.h },
      { x: p.x + p.w, y: p.y + p.h }
    ];
  }

  function getGroupBounds() {
    const selected = selectedIndices.map(i => world.platforms[i]);
    const minX = Math.min(...selected.map(p => p.x));
    const minY = Math.min(...selected.map(p => p.y));
    const maxX = Math.max(...selected.map(p => p.x + p.w));
    const maxY = Math.max(...selected.map(p => p.y + p.h));
    return { x: minX, y: minY, w: maxX - minX, h: maxY - minY };
  }

  // --- Redraw everything ---
  function redraw() {
    ctx.fillStyle = '#222';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Floor
    ctx.fillStyle = '#444';
    ctx.fillRect(-cameraX, worldHeight - 40 - cameraY, worldWidth, 40);

    // Platforms
    world.platforms.forEach((p, i) => {
      ctx.save();
      ctx.translate(p.x - cameraX + p.w / 2, p.y - cameraY + p.h / 2);
      ctx.rotate((p.rotation * Math.PI) / 180);
      ctx.fillStyle =
        p.material === 'ice'    ? '#3b82f6' :
        p.material === 'lava'   ? '#ef4444' :
        p.material === 'bounce' ? '#facc15' :
        p.material === 'sticky' ? '#10b981' :
                                  '#888';
      ctx.fillRect(-p.w / 2, -p.h / 2, p.w, p.h);
      ctx.restore();

      // Selection handles
      if (selectedIndices.includes(i)) {
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.strokeRect(p.x - cameraX, p.y - cameraY, p.w, p.h);

        // Corner handles
        ctx.fillStyle = '#fff';
        getHandles(p).forEach(h =>
          ctx.fillRect(h.x - cameraX - 4, h.y - cameraY - 4, 8, 8)
        );

        // Rotation handle
        const cx = p.x + p.w / 2;
        const hy = p.y - 40;
        ctx.fillStyle = '#0ff';
        ctx.beginPath();
        ctx.arc(cx - cameraX, hy - cameraY, 6, 0, Math.PI * 2);
        ctx.fill();
        p.rotationHandle = { x: cx, y: hy };
      }
    });

    // Group box
    if (selectedIndices.length > 1) {
      const bounds = getGroupBounds();
      ctx.strokeStyle = '#0ff';
      ctx.strokeRect(bounds.x - cameraX, bounds.y - cameraY, bounds.w, bounds.h);

      ctx.fillStyle = '#0ff';
      [
        { x: bounds.x, y: bounds.y },
        { x: bounds.x + bounds.w, y: bounds.y },
        { x: bounds.x, y: bounds.y + bounds.h },
        { x: bounds.x + bounds.w, y: bounds.y + bounds.h }
      ].forEach(h =>
        ctx.fillRect(h.x - cameraX - 4, h.y - cameraY - 4, 8, 8)
      );
    }

    // Marquee selection
    if (selectingBox) {
      const x = Math.min(selectStartX, selectCurrentX) - cameraX;
      const y = Math.min(selectStartY, selectCurrentY) - cameraY;
      const w = Math.abs(selectCurrentX - selectStartX);
      const h = Math.abs(selectCurrentY - selectStartY);
      ctx.strokeStyle = '#0ff';
      ctx.lineWidth = 1;
      ctx.strokeRect(x, y, w, h);
      ctx.fillStyle = 'rgba(0,255,255,0.2)';
      ctx.fillRect(x, y, w, h);
    }

    // Compact JSON output
    output.value = world.platforms
      .map(p => JSON.stringify({
        x: p.x, y: p.y, w: p.w, h: p.h,
        rotation: p.rotation, material: p.material
      }))
      .join('\n');
  }

  // --- Buttons ---
  addBtn.addEventListener('click', () => {
    world.platforms.push({
      x: cameraX + 100,
      y: cameraY + 100,
      w: 200,
      h: 20,
      rotation: 0,
      material: materialSelect.value
    });
    selectedIndices = [world.platforms.length - 1];
  });

  deleteBtn.addEventListener('click', () => {
    world.platforms = world.platforms.filter((_, i) => !selectedIndices.includes(i));
    selectedIndices = [];
  });

  saveBtn.addEventListener('click', () => {
    output.value = world.platforms.map(p => JSON.stringify(p)).join('\n');
  });

  copyBtn.addEventListener('click', () => {
    output.select();
    document.execCommand('copy');
    alert('JSON copied!');
  });

  loadFile.addEventListener('change', e => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = evt => {
      try {
        const data = JSON.parse(evt.target.result);
        world.platforms = Array.isArray(data) ? data : data.platforms || [];
        selectedIndices = [];
      } catch {
        alert('Error loading map');
      }
    };
    reader.readAsText(file);
  });

  // --- Load from text ---
  loadTextBtn.addEventListener('click', () => {
    try {
      const raw = jsonInput.value.trim();
      let parsed;

      if (raw.startsWith('[') && raw.endsWith(']')) {
        parsed = JSON.parse(raw);
      } else {
        const lines = raw.split('\n')
          .map(l => l.trim())
          .filter(Boolean)
          .map(l => l.replace(/,?\s*$/, ''));
        parsed = JSON.parse(`[${lines.join(',')}]`);
      }

      if (!Array.isArray(parsed)) throw new Error('Expected an array');

      world.platforms = parsed.map(p => ({
        x: Number(p.x), y: Number(p.y),
        w: Number(p.w), h: Number(p.h),
        rotation: Number(p.rotation),
        material: String(p.material)
      }));
      selectedIndices = [];
      redraw();
    } catch (err) {
      alert(`Invalid JSON text: ${err.message}`);
    }
  });

  // --- Mouse events ---
  let selectingBox = false;
  let selectStartX = 0, selectStartY = 0;
  let selectCurrentX = 0, selectCurrentY = 0;

  canvas.addEventListener('mousedown', e => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left + cameraX;
    const my = e.clientY - rect.top + cameraY;

    const found = world.platforms.findIndex(
      p => mx >= p.x && mx <= p.x + p.w && my >= p.y && my <= p.y + p.h
    );

    if (found === -1) {
      selectingBox = true;
      selectStartX = mx; selectStartY = my;
      selectCurrentX = mx; selectCurrentY = my;
      selectedIndices = [];
    } else {
      selectedIndices = [found];
      const p = world.platforms[found];
      draggingPlatform = true;
      dragOffsetX = mx - p.x;
      dragOffsetY = my - p.y;
    }
  });

  canvas.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left + cameraX;
    const my = e.clientY - rect.top + cameraY;

    if (selectingBox) {
      selectCurrentX = mx;
      selectCurrentY = my;
      return;
    }

    if (draggingPlatform && selectedIndices.length > 0) {
      selectedIndices.forEach(i => {
        const p = world.platforms[i];
        p.x = mx - dragOffsetX;
        p.y = my - dragOffsetY;
      });
    }
  });

  canvas.addEventListener('mouseup', () => {
    if (selectingBox) {
      selectingBox = false;
      const x1 = Math.min(selectStartX, selectCurrentX);
      const y1 = Math.min(selectStartY, selectCurrentY);
      const x2 = Math.max(selectStartX, selectCurrentX);
      const y2 = Math.max(selectStartY, selectCurrentY);

      selectedIndices = world.platforms
        .map((p, i) => {
          const intersects = !(
            p.x + p.w < x1 ||
            p.x > x2 ||
            p.y + p.h < y1 ||
            p.y > y2
          );
          return intersects ? i : null;
        })
        .filter(i => i !== null);
    }

    dragHandle = null;
    draggingPlatform = false;
    rotatingPlatform = false;
  });

  // --- Camera scrolling ---
  document.addEventListener('keydown', e => {
    const step = 50;
    if (e.key === 'ArrowLeft' || e.key === 'a') {
      cameraX = Math.max(0, cameraX - step);
    }
    if (e.key === 'ArrowRight' || e.key === 'd') {
      cameraX = Math.min(worldWidth - canvas.width, cameraX + step);
    }
    if (e.key === 'ArrowUp' || e.key === 'w') {
      cameraY = Math.max(0, cameraY - step);
    }
    if (e.key === 'ArrowDown' || e.key === 's') {
      cameraY = Math.min(worldHeight - canvas.height, cameraY + step);
    }
  });

  // --- Auto-update loop ---
  function gameLoop() {
    redraw();
    requestAnimationFrame(gameLoop);
  }

  // --- Initialize ---
  window.addEventListener('load', () => {
    document.getElementById('loading').style.display = 'none';
    resizeCanvas();
    gameLoop();
  });
</script>
</body>
</html>
