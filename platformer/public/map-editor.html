<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Map Editor (Stable + Materials)</title>
  <style>
    body { margin:0; height:100vh; display:flex; font-family:"Segoe UI",sans-serif; background:#0f0f0f; color:#eee; }
    #toolbox { width:240px; background:#1a1a1a; padding:12px; border-right:1px solid #333; display:flex; flex-direction:column; gap:10px; }
    #toolbox h3 { margin:0 0 8px; font-size:15px; }
    #toolbox label { font-size:13px; display:flex; flex-direction:column; gap:4px; }
    #toolbox select, #toolbox input { padding:6px; background:#111; color:#eee; border:1px solid #333; border-radius:4px; }
    #toolbox button { background:#3b82f6; color:#fff; border:none; border-radius:6px; padding:8px; cursor:pointer; font-size:13px; }
    #toolbox button:hover { background:#2563eb; }
    #editorArea { flex:1; display:flex; flex-direction:column; background:#1a1a1a; }
    #canvas { flex:1; background:#222; }
    #jsonPanel { width:360px; background:#121212; border-left:1px solid #333; display:flex; flex-direction:column; }
    #jsonPanel h3 { margin:0; padding:12px; font-size:14px; background:#1f1f1f; border-bottom:1px solid #333; }
    #editorOutput { flex:1; width:100%; border:none; resize:none; padding:12px; font-family:monospace; font-size:13px; background:#0f0f0f; color:#eee; overflow:auto; white-space:pre; }
    #copyBtn { background:#3b82f6; border:none; color:#fff; padding:8px; cursor:pointer; font-size:13px; }
    #copyBtn:hover { background:#2563eb; }
    #infoPanel { width:260px; background:#1a1a1a; padding:12px; border-left:1px solid #333; overflow-y:auto; }
    #infoPanel h3 { margin:0 0 8px; font-size:14px; }
    #infoPanel ul { list-style:none; padding:0; margin:0; }
    #infoPanel li { font-size:13px; margin:6px 0; }
    #loading { position:fixed; top:0; left:0; right:0; bottom:0; background:#0f0f0f; color:#fff; display:flex; align-items:center; justify-content:center; font-size:20px; z-index:9999; }
  </style>
</head>
<body>
  <div id="loading">Loading map editor...</div>

  <div id="toolbox">
    <h3>Tools</h3>
    <label>Material:
      <select id="materialSelect">
        <option value="normal">Normal</option>
        <option value="ice">Ice</option>
        <option value="lava">Lava</option>
        <option value="bounce">Bounce</option>
        <option value="sticky">Sticky</option>
      </select>
    </label>
    <label>Rotation:
      <input type="number" id="rotationInput" value="0" step="5">°
    </label>
    <button id="addBtn">Add Platform</button>
    <button id="deleteBtn">Delete Selected</button>
    <button id="saveBtn">Save JSON</button>
    <label>Load Map:
      <input type="file" id="loadFile" accept="application/json">
    </label>
    <textarea id="jsonInput" placeholder="Paste JSON here"></textarea>
    <button id="loadTextBtn">Load from Text</button>
  </div>

  <div id="editorArea">
    <canvas id="canvas"></canvas>
  </div>

  <div id="jsonPanel">
    <h3>JSON Output</h3>
    <textarea id="editorOutput" readonly></textarea>
    <button id="copyBtn">Copy JSON</button>
  </div>

  <div id="infoPanel">
    <h3>Instructions</h3>
    <ul>
      <li>Click a block to select it.</li>
      <li>Drag inside block to move it.</li>
      <li>Drag corner handles to resize.</li>
      <li>Drag cyan circle above block to rotate.</li>
      <li>Use arrow keys/WASD to scroll camera.</li>
      <li>Choose material & rotation before adding new blocks.</li>
    </ul>
  </div>

 <script>
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const output = document.getElementById('editorOutput');
  const addBtn = document.getElementById('addBtn');
  const deleteBtn = document.getElementById('deleteBtn');
  const saveBtn = document.getElementById('saveBtn');
  const copyBtn = document.getElementById('copyBtn');
  const loadFile = document.getElementById('loadFile');
  const materialSelect = document.getElementById('materialSelect');
  const rotationInput = document.getElementById('rotationInput');
  const loadTextBtn = document.getElementById('loadTextBtn');   // new button
  const jsonInput = document.getElementById('jsonInput');       // new textarea

  const worldWidth = 4000, worldHeight = 2000;
  let cameraX = 0, cameraY = 0;
  let world = { platforms: [] };
  let selectedIndices = [];
  let dragHandle = null, draggingPlatform = false, rotatingPlatform = false;
  let dragOffsetX = 0, dragOffsetY = 0;

  function resizeCanvas() {
    canvas.width =
      window.innerWidth -
      document.getElementById('jsonPanel').offsetWidth -
      document.getElementById('toolbox').offsetWidth -
      document.getElementById('infoPanel').offsetWidth;
    canvas.height = window.innerHeight;
  }
  window.addEventListener('resize', resizeCanvas);

  function getHandles(p) {
    return [
      { x: p.x, y: p.y },
      { x: p.x + p.w, y: p.y },
      { x: p.x, y: p.y + p.h },
      { x: p.x + p.w, y: p.y + p.h }
    ];
  }

  function getGroupBounds() {
    const selected = selectedIndices.map(i => world.platforms[i]);
    const minX = Math.min(...selected.map(p => p.x));
    const minY = Math.min(...selected.map(p => p.y));
    const maxX = Math.max(...selected.map(p => p.x + p.w));
    const maxY = Math.max(...selected.map(p => p.y + p.h));
    return { x: minX, y: minY, w: maxX - minX, h: maxY - minY };
  }

  function redraw() {
    ctx.fillStyle = '#222';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Floor
    ctx.fillStyle = '#444';
    ctx.fillRect(-cameraX, worldHeight - 40 - cameraY, worldWidth, 40);

    // Draw all platforms
    world.platforms.forEach((p, i) => {
      ctx.save();
      ctx.translate(p.x - cameraX + p.w / 2, p.y - cameraY + p.h / 2);
      ctx.rotate((p.rotation * Math.PI) / 180);
      ctx.fillStyle =
        p.material === 'ice'
          ? '#3b82f6'
          : p.material === 'lava'
          ? '#ef4444'
          : p.material === 'bounce'
          ? '#facc15'
          : p.material === 'sticky'
          ? '#10b981'
          : '#888';
      ctx.fillRect(-p.w / 2, -p.h / 2, p.w, p.h);
      ctx.restore();

      // Single‑block handles if selected
      if (selectedIndices.includes(i)) {
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.strokeRect(p.x - cameraX, p.y - cameraY, p.w, p.h);

        // Corner handles
        const handles = getHandles(p);
        ctx.fillStyle = '#fff';
        handles.forEach(h =>
          ctx.fillRect(h.x - cameraX - 4, h.y - cameraY - 4, 8, 8)
        );

        // Rotation handle
        const cx = p.x + p.w / 2;
        const hy = p.y - 40;
        ctx.fillStyle = '#0ff';
        ctx.beginPath();
        ctx.arc(cx - cameraX, hy - cameraY, 6, 0, Math.PI * 2);
        ctx.fill();
        p.rotationHandle = { x: cx, y: hy };
      }
    });

    // Group box if multiple selected
    if (selectedIndices.length > 1) {
      const bounds = getGroupBounds();
      ctx.strokeStyle = '#0ff';
      ctx.strokeRect(bounds.x - cameraX, bounds.y - cameraY, bounds.w, bounds.h);

      // Group handles
      const handles = [
        { x: bounds.x, y: bounds.y },
        { x: bounds.x + bounds.w, y: bounds.y },
        { x: bounds.x, y: bounds.y + bounds.h },
        { x: bounds.x + bounds.w, y: bounds.y + bounds.h }
      ];
      ctx.fillStyle = '#0ff';
      handles.forEach(h =>
        ctx.fillRect(h.x - cameraX - 4, h.y - cameraY - 4, 8, 8)
      );
    }

    // Marquee selection box
    if (selectingBox) {
      const x = Math.min(selectStartX, selectCurrentX) - cameraX;
      const y = Math.min(selectStartY, selectCurrentY) - cameraY;
      const w = Math.abs(selectCurrentX - selectStartX);
      const h = Math.abs(selectCurrentY - selectStartY);
      ctx.strokeStyle = '#0ff';
      ctx.lineWidth = 1;
      ctx.strokeRect(x, y, w, h);
      ctx.fillStyle = 'rgba(0,255,255,0.2)';
      ctx.fillRect(x, y, w, h);
    }

    // Compact JSON output: one block per line
    output.value = world.platforms
  .map(p => JSON.stringify({
    x: p.x, y: p.y, w: p.w, h: p.h, rotation: p.rotation, material: p.material
  }))
  .join('\n');

  }

  addBtn.addEventListener('click', () => {
    const newPlat = {
      x: cameraX + 100,
      y: cameraY + 100,
      w: 200,
      h: 20,
      rotation: parseInt(rotationInput.value, 10) || 0,
      material: materialSelect.value
    };
    world.platforms.push(newPlat);
    selectedIndices = [world.platforms.length - 1];
  });

  deleteBtn.addEventListener('click', () => {
    if (selectedIndices.length > 0) {
      world.platforms = world.platforms.filter(
        (_, i) => !selectedIndices.includes(i)
      );
      selectedIndices = [];
    }
  });

  saveBtn.addEventListener('click', () => {
    output.value = world.platforms.map(p => JSON.stringify(p)).join("\n");
  });

  copyBtn.addEventListener('click', () => {
    output.select();
    document.execCommand('copy');
    alert('JSON copied!');
  });

  loadFile.addEventListener('change', e => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = evt => {
      try {
        const data = JSON.parse(evt.target.result);
        world.platforms = Array.isArray(data) ? data : data.platforms || [];
        selectedIndices = [];
      } catch (err) {
        alert('Error loading map');
      }
    };
    reader.readAsText(file);
  });

  // Load JSON from text area (robust: handles array or one-per-line)
loadTextBtn.addEventListener('click', () => {
  try {
    const raw = jsonInput.value.trim();

    // 1) Determine input format
    let parsed;
    if (raw.startsWith('[') && raw.endsWith(']')) {
      // Full JSON array
      parsed = JSON.parse(raw);
    } else {
      // One object per line (no brackets)
      const lines = raw.split('\n').map(l => l.trim()).filter(Boolean);
      const jsonArray = `[${lines.join(',')}]`;
      parsed = JSON.parse(jsonArray);
    }

    // 2) Validate it’s an array of objects
    if (!Array.isArray(parsed)) {
      throw new Error('Expected an array of platform objects.');
    }

    // 3) Normalize: keep only expected fields
    const normalized = parsed.map((p, idx) => {
      if (typeof p !== 'object' || p === null) {
        throw new Error(`Item ${idx} is not an object.`);
      }
      // Required fields
      const hasFields = ['x','y','w','h','rotation','material'].every(k => k in p);
      if (!hasFields) {
        throw new Error(`Item ${idx} is missing required fields (x,y,w,h,rotation,material).`);
      }
      return {
        x: Number(p.x),
        y: Number(p.y),
        w: Number(p.w),
        h: Number(p.h),
        rotation: Number(p.rotation),
        material: String(p.material)
      };
    });

    // 4) Apply and redraw
    world.platforms = normalized;
    selectedIndices = [];
    redraw();
  } catch (err) {
    alert(`Invalid JSON text: ${err.message}`);
  }
});


  // Mouse events
  let selectingBox = false;
  let selectStartX = 0, selectStartY = 0;
  let selectCurrentX = 0, selectCurrentY = 0;

  canvas.addEventListener('mousedown', e => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left + cameraX;
    const my = e.clientY - rect.top + cameraY;

    const found = world.platforms.findIndex(
      p => mx >= p.x && mx <= p.x + p.w && my >= p.y && my <= p.y + p.h
    );

    if (found === -1) {
      selectingBox = true;
      selectStartX = mx;
      selectStartY = my;
      selectCurrentX = mx;
      selectCurrentY = my;
      selectedIndices = [];
    } else {
      selectedIndices = [found];
      const p = world.platforms[found];
      draggingPlatform = true;
      dragOffsetX = mx - p.x;
      dragOffsetY = my - p.y;
    }
  });

    canvas.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left + cameraX;
    const my = e.clientY - rect.top + cameraY;

    if (selectingBox) {
      selectCurrentX = mx;
      selectCurrentY = my;
      return;
    }

    if (draggingPlatform && selectedIndices.length > 0) {
      selectedIndices.forEach(i => {
        const p = world.platforms[i];
        p.x = mx - dragOffsetX;
        p.y = my - dragOffsetY;
      });
    }
  });

  canvas.addEventListener('mouseup', () => {
    if (selectingBox) {
      selectingBox = false;
      const x1 = Math.min(selectStartX, selectCurrentX);
      const y1 = Math.min(selectStartY, selectCurrentY);
      const x2 = Math.max(selectStartX, selectCurrentX);
      const y2 = Math.max(selectStartY, selectCurrentY);

      selectedIndices = world.platforms
        .map((p, i) => {
          const intersects = !(
            p.x + p.w < x1 ||
            p.x > x2 ||
            p.y + p.h < y1 ||
            p.y > y2
          );
          return intersects ? i : null;
        })
        .filter(i => i !== null);
    }

    dragHandle = null;
    draggingPlatform = false;
    rotatingPlatform = false;
  });

  // Camera scrolling
  document.addEventListener('keydown', e => {
    const step = 50;
    if (e.key === 'ArrowLeft' || e.key === 'a') {
      cameraX = Math.max(0, cameraX - step);
    }
    if (e.key === 'ArrowRight' || e.key === 'd') {
      cameraX = Math.min(worldWidth - canvas.width, cameraX + step);
    }
    if (e.key === 'ArrowUp' || e.key === 'w') {
      cameraY = Math.max(0, cameraY - step);
    }
    if (e.key === 'ArrowDown' || e.key === 's') {
      cameraY = Math.min(worldHeight - canvas.height, cameraY + step);
    }
  });

  // Auto-update loop
  function gameLoop() {
    redraw();
    requestAnimationFrame(gameLoop);
  }

  // Initialize
  window.addEventListener('load', () => {
    document.getElementById('loading').style.display = 'none';
    resizeCanvas();
    gameLoop();
  });
</script>
</body>
</html>

</body>
</html>

