<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Map Editor (Stable + Materials)</title>
  <style>
    body { margin:0; height:100vh; display:flex; font-family:"Segoe UI",sans-serif; background:#0f0f0f; color:#eee; }
    #editorArea { flex:1; display:flex; flex-direction:column; background:#1a1a1a; }
    #canvas { flex:1; background:#222; }
    #jsonPanel { width:360px; background:#121212; border-left:1px solid #333; display:flex; flex-direction:column; }
    #jsonPanel h3 { margin:0; padding:12px; font-size:14px; background:#1f1f1f; border-bottom:1px solid #333; }
    #editorOutput { flex:1; width:100%; border:none; resize:none; padding:12px; font-family:monospace; font-size:13px; background:#0f0f0f; color:#eee; overflow:auto; white-space:pre; }
    #copyBtn { background:#3b82f6; border:none; color:#fff; padding:8px; cursor:pointer; font-size:13px; }
    #copyBtn:hover { background:#2563eb; }
    #infoPanel { width:260px; background:#1a1a1a; padding:12px; border-left:1px solid #333; overflow-y:auto; }
    #infoPanel h3 { margin:0 0 8px; font-size:14px; }
    #infoPanel ul { list-style:none; padding:0; margin:0; }
    #infoPanel li { font-size:13px; margin:6px 0; }
    #toolbar {position:fixed;top:0;left:0;right:0;height:40px;display:flex;flex-direction:row;align-items:center;gap:8px;padding:6px;background:#333;color:#fff;z-index:1000;}
    #toolbar button,#toolbar select,#toolbar input {padding:4px 8px;font-size:14px;}
    #canvas {position:absolute;top:40px;left:0;}
    #jsonPanel {position:absolute;top:40px;right:0;width:300px;height:calc(100% - 40px);background:#111;color:#fff;display:flex;flex-direction:column;}
    #editorOutput,#jsonInput {flex:1;margin:4px;font-size:12px;background:#222;color:#0ff;}
  </style>
</head>
<body>
  <!-- Toolbar at the top -->
  <div id="toolbar">
    <button id="addBtn">Add</button>
    <button id="deleteBtn">Delete</button>
    <button id="saveBtn">Save</button>
    <button id="copyBtn">Copy</button>
    <input type="file" id="loadFile" />
    <select id="materialSelect">
      <option value="normal">Normal</option>
      <option value="ice">Ice</option>
      <option value="lava">Lava</option>
      <option value="bounce">Bounce</option>
      <option value="sticky">Sticky</option>
    </select>
    <button id="helpBtn">Help</button>
  </div>

  <!-- Canvas area -->
  <canvas id="canvas"></canvas>

  <!-- JSON panel -->
  <div id="jsonPanel">
    <textarea id="editorOutput"></textarea>
    <textarea id="jsonInput" placeholder="Paste JSON here"></textarea>
    <button id="loadTextBtn">Load from Text</button>
  </div>
<script>
  document.getElementById('helpBtn').addEventListener('click', () => {
      alert("Controls:\n- Arrow keys/WASD: Move camera\n- Click+Drag: Move block\n- Drag box: Select multiple\n- Rotation handle above block: Rotate\n- Toolbar buttons: Add/Delete/Save/Copy/Load");
  });

   // --- Canvas and context ---
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  // --- UI elements ---
  const addBtn = document.getElementById('addBtn');
  const deleteBtn = document.getElementById('deleteBtn');
  const saveBtn = document.getElementById('saveBtn');
  const copyBtn = document.getElementById('copyBtn');
  const loadFile = document.getElementById('loadFile');
  const loadTextBtn = document.getElementById('loadTextBtn');
  const materialSelect = document.getElementById('materialSelect');
  const jsonInput = document.getElementById('jsonInput');
  const output = document.getElementById('editorOutput');

  // --- World and camera state ---
  const worldWidth = 4000, worldHeight = 2000;
  let cameraX = 0, cameraY = 0;
  let world = { platforms: [] };
  let selectedIndices = [];

  // --- Dragging state ---
  let dragHandle = null;
  let draggingPlatform = false;
  let rotatingPlatform = false;
  let dragOffsetX = 0, dragOffsetY = 0;

  // --- Selection state ---
  let selectingBox = false;
  let selectStartX = 0, selectStartY = 0;
  let selectCurrentX = 0, selectCurrentY = 0;
  let scalingGroup = false;
  let startBounds, startMouse;


  // --- Canvas resize ---
  function resizeCanvas() {
      const jsonPanel = document.getElementById('jsonPanel');
      const panelWidth = jsonPanel ? jsonPanel.offsetWidth : 0;
      canvas.width = window.innerWidth - panelWidth;
      canvas.height = window.innerHeight;
    }
    

  // --- Helpers ---
  function getHandles(p) {
    return [
      { x: p.x, y: p.y },
      { x: p.x + p.w, y: p.y },
      { x: p.x, y: p.y + p.h },
      { x: p.x + p.w, y: p.y + p.h }
    ];
  }

    // --- Helpers for group transforms ---
  function getGroupBounds() {
    const selected = selectedIndices.map(i => world.platforms[i]);
    const minX = Math.min(...selected.map(p => p.x));
    const minY = Math.min(...selected.map(p => p.y));
    const maxX = Math.max(...selected.map(p => p.x + p.w));
    const maxY = Math.max(...selected.map(p => p.y + p.h));
    return { x: minX, y: minY, w: maxX - minX, h: maxY - minY };
  }

  // --- Redraw everything ---
  function redraw() {
    ctx.fillStyle = '#222';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Floor
    ctx.fillStyle = '#444';
    ctx.fillRect(-cameraX, worldHeight - 40 - cameraY, worldWidth, 40);

    // Platforms
    world.platforms.forEach((p, i) => {
      ctx.save();
      ctx.translate(p.x - cameraX + p.w / 2, p.y - cameraY + p.h / 2);
      ctx.rotate((p.rotation * Math.PI) / 180);
      ctx.fillStyle =
        p.material === 'ice'    ? '#3b82f6' :
        p.material === 'lava'   ? '#ef4444' :
        p.material === 'bounce' ? '#facc15' :
        p.material === 'sticky' ? '#10b981' :
                                  '#888';
      ctx.fillRect(-p.w / 2, -p.h / 2, p.w, p.h);
      ctx.restore();

      // Selection handles
      if (selectedIndices.includes(i)) {
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.strokeRect(p.x - cameraX, p.y - cameraY, p.w, p.h);

        // Corner handles
        ctx.fillStyle = '#fff';
        getHandles(p).forEach(h =>
          ctx.fillRect(h.x - cameraX - 4, h.y - cameraY - 4, 8, 8)
        );

        // Rotation handle
        const cx = p.x + p.w / 2;
        const hy = p.y - 40;
        ctx.fillStyle = '#0ff';
        ctx.beginPath();
        ctx.arc(cx - cameraX, hy - cameraY, 6, 0, Math.PI * 2);
        ctx.fill();
        p.rotationHandle = { x: cx, y: hy };
      }
    });

    // Group box
    if (selectedIndices.length > 1) {
      const bounds = getGroupBounds();
      ctx.strokeStyle = '#0ff';
      ctx.strokeRect(bounds.x - cameraX, bounds.y - cameraY, bounds.w, bounds.h);

      ctx.fillStyle = '#0ff';
      [
        { x: bounds.x, y: bounds.y },
        { x: bounds.x + bounds.w, y: bounds.y },
        { x: bounds.x, y: bounds.y + bounds.h },
        { x: bounds.x + bounds.w, y: bounds.y + bounds.h }
      ].forEach(h =>
        ctx.fillRect(h.x - cameraX - 4, h.y - cameraY - 4, 8, 8)
      );
    }

    // Marquee selection
    if (selectingBox) {
      const x = Math.min(selectStartX, selectCurrentX) - cameraX;
      const y = Math.min(selectStartY, selectCurrentY) - cameraY;
      const w = Math.abs(selectCurrentX - selectStartX);
      const h = Math.abs(selectCurrentY - selectStartY);
      ctx.strokeStyle = '#0ff';
      ctx.lineWidth = 1;
      ctx.strokeRect(x, y, w, h);
      ctx.fillStyle = 'rgba(0,255,255,0.2)';
      ctx.fillRect(x, y, w, h);
    }

    // Compact JSON output
    output.value = world.platforms
      .map(p => JSON.stringify({
        x: p.x, y: p.y, w: p.w, h: p.h,
        rotation: p.rotation, material: p.material
      }))
      .join(',\n');
  }

  // --- Buttons ---
  addBtn.addEventListener('click', () => {
    world.platforms.push({
      x: cameraX + 100,
      y: cameraY + 100,
      w: 200,
      h: 20,
      rotation: 0,
      material: materialSelect.value
    });
    selectedIndices = [world.platforms.length - 1];
  });

  deleteBtn.addEventListener('click', () => {
    world.platforms = world.platforms.filter((_, i) => !selectedIndices.includes(i));
    selectedIndices = [];
  });

  saveBtn.addEventListener('click', () => {
    output.value = world.platforms.map(p => JSON.stringify(p)).join('\n');
  });

  copyBtn.addEventListener('click', () => {
    output.select();
    document.execCommand('copy');
    alert('JSON copied!');
  });

  loadFile.addEventListener('change', e => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = evt => {
      try {
        const data = JSON.parse(evt.target.result);
        world.platforms = Array.isArray(data) ? data : data.platforms || [];
        selectedIndices = [];
      } catch {
        alert('Error loading map');
      }
    };
    reader.readAsText(file);
  });

  // --- Load from text ---
  loadTextBtn.addEventListener('click', () => {
    try {
      const raw = jsonInput.value.trim();
      let parsed;

      if (raw.startsWith('[') && raw.endsWith(']')) {
        parsed = JSON.parse(raw);
      } else {
        const lines = raw.split('\n')
          .map(l => l.trim())
          .filter(Boolean)
          .map(l => l.replace(/,?\s*$/, ''));
        parsed = JSON.parse(`[${lines.join(',')}]`);
      }

      if (!Array.isArray(parsed)) throw new Error('Expected an array');

      world.platforms = parsed.map(p => ({
        x: Number(p.x), y: Number(p.y),
        w: Number(p.w), h: Number(p.h),
        rotation: Number(p.rotation),
        material: String(p.material)
      }));
      selectedIndices = [];
      redraw();
    } catch (err) {
      alert(`Invalid JSON text: ${err.message}`);
    }
  });

    canvas.addEventListener('mousedown', e => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left + cameraX;
      const my = e.clientY - rect.top + cameraY;

      const found = world.platforms.findIndex(
        p => mx >= p.x && mx <= p.x + p.w && my >= p.y && my <= p.y + p.h
      );

      if (found === -1) {
        selectingBox = true;
        selectStartX = mx; selectStartY = my;
        selectCurrentX = mx; selectCurrentY = my;
        selectedIndices = [];
      } else {
        if (!selectedIndices.includes(found)) {
          selectedIndices = [found];
        }
        // prepare drag offsets for all selected
        dragOffsets = {};
        selectedIndices.forEach(i => {
          const p = world.platforms[i];
          dragOffsets[i] = { dx: mx - p.x, dy: my - p.y };
        });
        draggingPlatform = true;
      }
    });

    canvas.addEventListener('mousedown', e => {
    if (selectedIndices.length > 1) {
      const bounds = getGroupBounds();
      const corners = [
        {x:bounds.x,y:bounds.y},
        {x:bounds.x+bounds.w,y:bounds.y},
        {x:bounds.x,y:bounds.y+bounds.h},
        {x:bounds.x+bounds.w,y:bounds.y+bounds.h}
      ];
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left + cameraX;
      const my = e.clientY - rect.top + cameraY;
      // check if clicked near a corner
      if (corners.some(c => Math.hypot(mx-c.x,my-c.y)<10)) {
        scalingGroup = true;
        startBounds = bounds;
        startMouse = {mx,my};
      }
    }
  });

  canvas.addEventListener('mousemove', e => {
    if (scalingGroup) {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left + cameraX;
      const my = e.clientY - rect.top + cameraY;

      // compute scale factors relative to original bounds
      const scaleX = (mx - startBounds.x) / startBounds.w;
      const scaleY = (my - startBounds.y) / startBounds.h;
      const cx = startBounds.x + startBounds.w/2;
      const cy = startBounds.y + startBounds.h/2;

      selectedIndices.forEach(i => {
        const p = world.platforms[i];
        const px = p.x + p.w/2;
        const py = p.y + p.h/2;
        const dx = px - cx;
        const dy = py - cy;
        p.x = cx + dx * scaleX - (p.w * scaleX)/2;
        p.y = cy + dy * scaleY - (p.h * scaleY)/2;
        p.w = p.w * scaleX;
        p.h = p.h * scaleY;
      });
    }
  });

  canvas.addEventListener('mouseup', () => {
    scalingGroup = false;
  });
  // --- Camera scrolling ---
  document.addEventListener('keydown', e => {
    const step = 50;
    if (e.key === 'ArrowLeft' || e.key === 'a') {
      cameraX = Math.max(0, cameraX - step);
    }
    if (e.key === 'ArrowRight' || e.key === 'd') {
      cameraX = Math.min(worldWidth - canvas.width, cameraX + step);
    }
    if (e.key === 'ArrowUp' || e.key === 'w') {
      cameraY = Math.max(0, cameraY - step);
    }
    if (e.key === 'ArrowDown' || e.key === 's') {
      cameraY = Math.min(worldHeight - canvas.height, cameraY + step);
    }
  });

  // --- Auto-update loop ---
  function gameLoop() {
    redraw();
    requestAnimationFrame(gameLoop);
  }

  // --- Initialize ---
  window.addEventListener('load', () => {
    resizeCanvas();
    gameLoop();
  });
</script>
</body>
</html>
