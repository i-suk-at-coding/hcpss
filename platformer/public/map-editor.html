<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Map Editor (Stable)</title>
  <style>
    body { margin:0; height:100vh; display:flex; font-family:"Segoe UI",sans-serif; background:#0f0f0f; color:#eee; }
    #toolbox { width:220px; background:#1a1a1a; padding:12px; border-right:1px solid #333; display:flex; flex-direction:column; gap:8px; }
    #editorArea { flex:1; display:flex; flex-direction:column; background:#1a1a1a; }
    #canvas { flex:1; background:#222; }
    #jsonPanel { width:400px; background:#121212; border-left:1px solid #333; display:flex; flex-direction:column; }
    #editorOutput { flex:1; width:100%; border:none; resize:none; padding:12px; font-family:monospace; font-size:13px; background:#0f0f0f; color:#eee; overflow:auto; white-space:pre; }
    #infoPanel { width:260px; background:#1a1a1a; padding:12px; border-left:1px solid #333; overflow-y:auto; }
    #loading { position:fixed; top:0; left:0; right:0; bottom:0; background:#0f0f0f; color:#fff; display:flex; align-items:center; justify-content:center; font-size:20px; z-index:9999; }
  </style>
</head>
<body>
  <div id="loading">Loading map editor...</div>

  <div id="toolbox">
    <button id="addBtn">Add Platform</button>
    <button id="deleteBtn">Delete Selected</button>
    <button id="saveBtn">Save JSON</button>
    <input type="file" id="loadFile" accept="application/json">
  </div>

  <div id="editorArea">
    <canvas id="canvas"></canvas>
  </div>

  <div id="jsonPanel">
    <h3>JSON Output</h3>
    <textarea id="editorOutput" readonly></textarea>
    <button id="copyBtn">Copy JSON</button>
  </div>

  <div id="infoPanel">
    <h3>Instructions</h3>
    <ul>
      <li>Click a block to select it.</li>
      <li>Drag inside block to move it.</li>
      <li>Drag corner handles to resize.</li>
      <li>Drag cyan circle above block to rotate.</li>
      <li>Use arrow keys/WASD to scroll camera.</li>
    </ul>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const output = document.getElementById('editorOutput');
    const addBtn = document.getElementById('addBtn');
    const deleteBtn = document.getElementById('deleteBtn');
    const saveBtn = document.getElementById('saveBtn');
    const copyBtn = document.getElementById('copyBtn');
    const loadFile = document.getElementById('loadFile');

    const worldWidth = 4000, worldHeight = 2000;
    let cameraX = 0, cameraY = 0;
    let world = { platforms: [] };
    let selectedIndex = null;
    let dragHandle = null, draggingPlatform = false, rotatingPlatform = false;
    let dragOffsetX = 0, dragOffsetY = 0;

    function resizeCanvas() {
      canvas.width = window.innerWidth - document.getElementById('jsonPanel').offsetWidth - document.getElementById('toolbox').offsetWidth - document.getElementById('infoPanel').offsetWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);

    function getHandles(p) {
      return [
        {x: p.x, y: p.y},
        {x: p.x + p.w, y: p.y},
        {x: p.x, y: p.y + p.h},
        {x: p.x + p.w, y: p.y + p.h}
      ];
    }

    function redraw() {
      ctx.fillStyle = '#222';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      world.platforms.forEach((p, i) => {
        ctx.save();
        ctx.translate(p.x - cameraX + p.w/2, p.y - cameraY + p.h/2);
        ctx.rotate(p.rotation * Math.PI/180);
        ctx.fillStyle = '#888';
        ctx.fillRect(-p.w/2, -p.h/2, p.w, p.h);
        ctx.restore();

        if (i === selectedIndex) {
          ctx.strokeStyle = '#fff';
          ctx.strokeRect(p.x - cameraX, p.y - cameraY, p.w, p.h);
          const handles = getHandles(p);
          ctx.fillStyle = '#fff';
          handles.forEach(h => ctx.fillRect(h.x - cameraX - 4, h.y - cameraY - 4, 8, 8));
          const cx = p.x + p.w/2;
          const hy = p.y - 40;
          ctx.fillStyle = '#0ff';
          ctx.beginPath();
          ctx.arc(cx - cameraX, hy - cameraY, 6, 0, Math.PI*2);
          ctx.fill();
          p.rotationHandle = {x: cx, y: hy};
        }
      });

      output.value = JSON.stringify(world.platforms, null, 2);
    }

    addBtn.addEventListener('click', () => {
      const newPlat = {x: cameraX+100, y: cameraY+100, w:200, h:20, rotation:0, material:"normal"};
      world.platforms.push(newPlat);
      selectedIndex = world.platforms.length - 1;
    });

    deleteBtn.addEventListener('click', () => {
      if (selectedIndex !== null) {
        world.platforms.splice(selectedIndex, 1);
        selectedIndex = null;
      }
    });

    saveBtn.addEventListener('click', () => {
      output.value = JSON.stringify(world.platforms, null, 2);
    });

    copyBtn.addEventListener('click', () => {
      output.select();
      document.execCommand('copy');
      alert('JSON copied!');
    });

    loadFile.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (evt) => {
        try {
          const data = JSON.parse(evt.target.result);
          world.platforms = Array.isArray(data) ? data : data.platforms || [];
          selectedIndex = null;
        } catch (err) { alert("Error loading map"); }
      };
      reader.readAsText(file);
    });

    // Mouse events
    canvas.addEventListener('mousedown', (e) => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left + cameraX;
      const my = e.clientY - rect.top + cameraY;
      if (selectedIndex !== null) {
        const p = world.platforms[selectedIndex];
        const handles = getHandles(p);
        const hit = handles.findIndex(h => Math.abs(mx - h.x) < 6 && Math.abs(my - h.y) < 6);
        if (hit !== -1) { dragHandle = hit; return; }
        if (p.rotationHandle && Math.hypot(mx - p.rotationHandle.x, my - p.rotationHandle.y) < 10) {
          rotatingPlatform = true; return;
        }
        if (mx >= p.x && mx <= p.x + p.w && my >= p.y && my <= p.y + p.h) {
          draggingPlatform = true;
          dragOffsetX = mx - p.x;
          dragOffsetY = my - p.y;
          return;
        }
      }
      // selection
      selectedIndex = world.platforms.findIndex(p => mx >= p.x && mx <= p.x+p.w && my >= p.y && my <= p.y+p.h);
    });

    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left + cameraX;
      const my = e.clientY - rect.top + cameraY;
      if (dragHandle !== null && selectedIndex !== null) {
        const p = world.platforms[selectedIndex];
        switch (dragHandle) {
          case 0: p.w = (p.x+p.w)-mx; p.h = (p.y+p.h)-my; p.x = mx; p.y = my; break;
          case 1: p.w = mx-p.x; p.h = (p.y+p.h)-my; p.y = my; break;
                    case 2: p.w = (p.x+p.w)-mx; p.h = my-p.y; p.x = mx; break;
          case 3: p.w = mx-p.x; p.h = my-p.y; break;
        }
      } else if (rotatingPlatform && selectedIndex !== null) {
        const p = world.platforms[selectedIndex];
        const cx = p.x + p.w/2;
        const cy = p.y + p.h/2;
        const angle = Math.atan2(my - cy, mx - cx) * 180/Math.PI;
        p.rotation = angle;
      } else if (draggingPlatform && selectedIndex !== null) {
        const p = world.platforms[selectedIndex];
        p.x = mx - dragOffsetX;
        p.y = my - dragOffsetY;
      }
    });

    canvas.addEventListener('mouseup', () => {
      dragHandle = null;
      draggingPlatform = false;
      rotatingPlatform = false;
    });

    // Camera scrolling
    document.addEventListener('keydown', (e) => {
      const step = 50;
      if (e.key === 'ArrowLeft' || e.key === 'a') cameraX = Math.max(0, cameraX - step);
      if (e.key === 'ArrowRight' || e.key === 'd') cameraX = Math.min(worldWidth - canvas.width, cameraX + step);
      if (e.key === 'ArrowUp' || e.key === 'w') cameraY = Math.max(0, cameraY - step);
      if (e.key === 'ArrowDown' || e.key === 's') cameraY = Math.min(worldHeight - canvas.height, cameraY + step);
    });

    // Auto-update loop
    function gameLoop() {
      redraw();
      requestAnimationFrame(gameLoop);
    }

    // Initialize
    window.addEventListener('load', () => {
      document.getElementById('loading').style.display = 'none';
      resizeCanvas();
      gameLoop();
    });
  </script>
</body>
</html>
