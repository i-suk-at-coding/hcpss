<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Platformer + Chat</title>
  <style>
    html,body{margin:0;padding:0;height:100%}
    body{margin:0;display:flex;height:100vh;background:#0f0f0f;color:#eee;font-family:"Segoe UI",sans-serif}
    #left{flex:1;display:flex;flex-direction:column}
    #hud{height:40px;background:#1a1a1a;display:flex;align-items:center;justify-content:space-between;padding:0 12px;border-bottom:1px solid #333}
    #hud span{font-size:14px}
    #editorBtn{background:#10b981;color:#fff;border:none;border-radius:6px;padding:6px 12px;cursor:pointer;margin-left:12px}
    #editorBtn:hover{background:#059669}
    #game{flex:1;display:flex;align-items:center;justify-content:center}
    #canvas{background:#222;border:1px solid #333}
    #right{width:320px;display:flex;flex-direction:column;border-left:1px solid #333}
    #players{background:#1a1a1a;padding:8px;border-bottom:1px solid #333}
    #players h3{margin:0 0 6px;font-size:14px}
    #players ul{list-style:none;padding:0;margin:0}
    #players li{font-size:13px;margin:4px 0;display:flex;align-items:center}
    .dot{width:8px;height:8px;border-radius:50%;margin-right:6px;background:#3b82f6}
    #messages{flex:1;list-style:none;margin:0;padding:10px;overflow-y:auto;overflow-x:hidden;background:#121212}
    #messages li{margin:6px 0;padding:8px 10px;border-radius:8px;background:#1f2937;font-size:13px;word-wrap:break-word;overflow-wrap:break-word;white-space:pre-wrap;max-width:260px}
    #messages li.self{background:#064e3b}
    #messages .time{font-size:11px;opacity:.6;margin-left:6px}
    #chatForm{display:flex;gap:6px;padding:10px;border-top:1px solid #333;background:#1a1a1a}
    #chatInput{flex:1;padding:8px;border:1px solid #333;border-radius:6px;background:#111;color:#eee}
    button{background:#3b82f6;color:#fff;border:none;border-radius:6px;padding:8px 12px;cursor:pointer}
    button:hover{background:#2563eb}
  </style>
</head>
<body>
  <div id="left">
    <div id="hud">
      <span>
        <span id="username">You:</span>
        <button id="editorBtn">Map Editor</button>
      </span>
      <span id="count">Players: 0</span>
    </div>
    <div id="game">
      <canvas id="canvas"></canvas>
    </div>
  </div>

  <div id="right">
    <div id="players">
      <h3>Online Players</h3>
      <ul id="playerList"></ul>
    </div>
    <ul id="messages"></ul>
    <form id="chatForm">
      <input id="chatInput" autocomplete="off" placeholder="Type a message..." />
      <button>Send</button>
    </form>
  </div>

<script src="/socket.io/socket.io.js"></script>
<script>
  const socket = io();
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const messages = document.getElementById('messages');
  const chatForm = document.getElementById('chatForm');
  const chatInput = document.getElementById('chatInput');
  const playerList = document.getElementById('playerList');
  const usernameLabel = document.getElementById('username');
  const countLabel = document.getElementById('count');

  function resizeCanvas() {
    canvas.width = window.innerWidth - document.getElementById('right').offsetWidth;
    canvas.height = window.innerHeight - document.getElementById('hud').offsetHeight;
  }
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);

  document.getElementById('editorBtn').addEventListener('click', () => {
    window.location.href = '/map-editor.html';
  });

  let myUsername = null;
  let world = null;
  let players = {};
  const SIZE = { w: 40, h: 60 };

  socket.on('auth', ({ username }) => {
    myUsername = username;
    usernameLabel.textContent = "You: " + username;
  });

  socket.on('world', (payload) => {
    world = payload.world;
    players = payload.players || {};
    updatePlayerList();
  });

  socket.on('player join', ({ username, state }) => {
    players[username] = state;
    updatePlayerList();
  });

  socket.on('player leave', ({ username }) => {
    delete players[username];
    updatePlayerList();
  });

  socket.on('state', (serverPlayers) => {
    players = serverPlayers;
    updatePlayerList();
  });

  const input = { left: false, right: false, up: false };
  const keymap = { ArrowLeft:'left', ArrowRight:'right', ArrowUp:'up', a:'left', d:'right', w:'up', ' ':'up' };

  window.addEventListener('keydown', (e) => {
    const k = keymap[e.key];
    if (!k) return;
    if (!input[k]) {
      input[k] = true;
      socket.emit('input', input);
    }
  });

  window.addEventListener('keyup', (e) => {
    const k = keymap[e.key];
    if (!k) return;
    input[k] = false;
    socket.emit('input', input);
  });

  chatForm.addEventListener('submit', (e) => {
    e.preventDefault();
    const text = chatInput.value.trim();
    if (!text) return;
    socket.emit('chat message', text);
    chatInput.value = '';
  });

  socket.on('chat history', (history) => {
    messages.innerHTML = '';
    history.forEach(addMessage);
  });

  socket.on('chat message', addMessage);

  function addMessage(msg) {
    const li = document.createElement('li');
    const time = document.createElement('span');
    time.className = 'time';
    time.textContent = new Date(msg.time).toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'});
    li.textContent = `${msg.user}: ${msg.text}`;
    li.appendChild(time);
    if (msg.user === myUsername) li.classList.add('self');
    messages.appendChild(li);
    messages.scrollTop = messages.scrollHeight;
  }

  function updatePlayerList() {
    playerList.innerHTML = '';
    Object.keys(players).forEach(u => {
      const li = document.createElement('li');
      const dot = document.createElement('div');
      dot.className = 'dot';
      dot.style.background = players[u].color || '#3b82f6';
      li.appendChild(dot);
      li.appendChild(document.createTextNode(u));
      playerList.appendChild(li);
    });
    countLabel.textContent = "Players: " + Object.keys(players).length;
  }

  // --- Rotated collision helpers ---
  function getRotRectCorners(p) {
    const cx = p.x + p.w / 2;
    const cy = p.y + p.h / 2;
    const rad = ((p.rotation || 0) * Math.PI) / 180;
    const local = [
      { x: -p.w/2, y: -p.h/2 },
      { x:  p.w/2, y: -p.h/2 },
      { x:  p.w/2, y:  p.h/2 },
      { x: -p.w/2, y:  p.h/2 }
    ];
    return local.map(v => ({
      x: cx + v.x * Math.cos(rad) - v.y * Math.sin(rad),
      y: cy + v.x * Math.sin(rad) + v.y * Math.cos(rad)
    }));
  }

  function getAABBCorners(ax, ay, aw, ah) {
    return [
      { x: ax,     y: ay     },
      { x: ax+aw,  y: ay     },
      { x: ax+aw,  y: ay+ah  },
      { x: ax,     y: ay+ah  }
    ];
  }

  function project(corners, axis) {
    let min = Infinity, max = -Infinity;
    for (const c of corners) {
      const s = (c.x * axis.x + c.y * axis.y);
      if (s < min) min = s;
      if (s > max) max = s;
    }
    return { min, max };
  }

  function normalize(v) {
    const len = Math.hypot(v.x, v.y);
    return len ? { x: v.x / len, y: v.y / len } : { x: 0, y: 0 };
  }

  function aabbVsRotRect(ax, ay, aw, ah, plat) {
    const rc = getRotRectCorners(plat);
    const pc = getAABBCorners(ax, ay, aw, ah);
    const axes = [];
    const e0 = { x: rc[1].x - rc[0].x, y: rc[1].y - rc[0].y };
    const e1 = { x: rc[3].x - rc[0].x, y: rc[3].y - rc[0].y };
    axes.push(normalize(e0));
    axes.push(normalize(e1));
    axes.push({ x: 1, y: 0 });
    axes.push({ x: 0, y: 1 });
    for (const axis of axes) {
      const pProj = project(pc, axis);
      const rProj = project(rc, axis);
      if (pProj.max < rProj.min || rProj.max < pProj.min) {
        return false;
      }
    }
    return true;
  }

  // --- Drawing players with slope rotation ---
  function drawPlayer(u, p) {
    ctx.save();
    ctx.translate(p.x + SIZE.w/2, p.y + SIZE.h/2);
    ctx.rotate((p.currentRotation || 0) * Math.PI / 180);

    ctx.fillStyle = p.color || '#a3e635';
    ctx.fillRect(-SIZE.w/2, -SIZE.h/2, SIZE.w, SIZE.h);

    ctx.fillStyle = '#000';
    const eyeOffsetX = p.dir === 1 ? SIZE.w/2 - 12 : -SIZE.w/2 + 4;
    ctx.fillRect(eyeOffsetX, -SIZE.h/2 + 16, 8, 8);

    ctx.fillStyle = '#e5e7eb';
    ctx.font = '12px Segoe UI';
    ctx.fillText(u, -SIZE.w/2, -SIZE.h/2 - 6);

    ctx.restore();
  }

  function render() {
  if (!world) return requestAnimationFrame(render);
  const me = players[myUsername];
  const camX = Math.max(0, Math.min((me ? me.x : 0) - canvas.width/2, world.width - canvas.width));
  const camY = Math.max(0, Math.min((me ? me.y : 0) - canvas.height/2, world.height - canvas.height));

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.save();
  ctx.translate(-camX, -camY);

  // Background
  ctx.fillStyle = '#222';
  ctx.fillRect(0, 0, world.width, world.height);

  // Platforms
  for (const plat of world.platforms) {
    ctx.save();
    ctx.translate(plat.x + plat.w/2, plat.y + plat.h/2);
    ctx.rotate((plat.rotation || 0) * Math.PI/180);
    const colors = { normal:"#888", ice:"#3b82f6", lava:"#ef4444", bounce:"#facc15", sticky:"#10b981" };
    ctx.fillStyle = colors[plat.material] || "#888";
    ctx.fillRect(-plat.w/2, -plat.h/2, plat.w, plat.h);
    ctx.restore();
  }
  // Players
  for (const [u, p] of Object.entries(players)) {
    // Collision check: find slope under player
    let targetRotation = 0;
    if (world && world.platforms) {
      for (const plat of world.platforms) {
        if (aabbVsRotRect(p.x, p.y, SIZE.w, SIZE.h, plat)) {
          targetRotation = plat.rotation || 0;
          break;
        }
      }
    }

    // Smooth interpolation toward slope angle
    if (p.currentRotation === undefined) p.currentRotation = 0;
    const lerpFactor = 0.1;
    p.currentRotation += (targetRotation - p.currentRotation) * lerpFactor;

    // Draw player with rotation
    drawPlayer(u, p);
  }

  ctx.restore();
  requestAnimationFrame(render);
}

requestAnimationFrame(render);
</script>

</body>
</html>
