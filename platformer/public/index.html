<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Platformer + Chat</title>
  <style>
    html,body{margin:0;padding:0;height:100%}
    body{margin:0;display:flex;height:100vh;background:#0f0f0f;color:#eee;font-family:"Segoe UI",sans-serif}
    #left{flex:1;display:flex;flex-direction:column}
    #hud{height:40px;background:#1a1a1a;display:flex;align-items:center;justify-content:space-between;padding:0 12px;border-bottom:1px solid #333}
    #hud span{font-size:14px}
    #editorBtn{background:#10b981;color:#fff;border:none;border-radius:6px;padding:6px 12px;cursor:pointer;margin-left:12px}
    #editorBtn:hover{background:#059669}
    #game{flex:1;display:flex;align-items:center;justify-content:center}
    #canvas{background:#222;border:1px solid #333}
    #right{width:320px;display:flex;flex-direction:column;border-left:1px solid #333}
    #players{background:#1a1a1a;padding:8px;border-bottom:1px solid #333}
    #players h3{margin:0 0 6px;font-size:14px}
    #players ul{list-style:none;padding:0;margin:0}
    #players li{font-size:13px;margin:4px 0;display:flex;align-items:center}
    .dot{width:8px;height:8px;border-radius:50%;margin-right:6px;background:#3b82f6}
    #messages{flex:1;list-style:none;margin:0;padding:10px;overflow-y:auto;overflow-x:hidden;background:#121212}
    #messages li{margin:6px 0;padding:8px 10px;border-radius:8px;background:#1f2937;font-size:13px;word-wrap:break-word;overflow-wrap:break-word;white-space:pre-wrap;max-width:260px}
    #messages li.self{background:#064e3b}
    #messages .time{font-size:11px;opacity:.6;margin-left:6px}
    #chatForm{display:flex;gap:6px;padding:10px;border-top:1px solid #333;background:#1a1a1a}
    #chatInput{flex:1;padding:8px;border:1px solid #333;border-radius:6px;background:#111;color:#eee}
    button{background:#3b82f6;color:#fff;border:none;border-radius:6px;padding:8px 12px;cursor:pointer}
    button:hover{background:#2563eb}
  </style>
</head>
<body>
  <div id="left">
    <div id="hud">
      <span>
        <span id="username">You:</span>
        <button id="editorBtn">Map Editor</button>
      </span>
      <span id="count">Players: 0</span>
    </div>
    <div id="game">
      <canvas id="canvas"></canvas>
    </div>
  </div>

  <div id="right">
    <div id="players">
      <h3>Online Players</h3>
      <ul id="playerList"></ul>
    </div>
    <ul id="messages"></ul>
    <form id="chatForm">
      <input id="chatInput" autocomplete="off" placeholder="Type a message..." />
      <button>Send</button>
    </form>
  </div>

<script src="/socket.io/socket.io.js"></script>
<script>
  // --- Socket & Canvas Setup ---
  const socket = io();
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d', { alpha: false });

  // --- UI Elements ---
  const messages = document.getElementById('messages');
  const chatForm = document.getElementById('chatForm');
  const chatInput = document.getElementById('chatInput');
  const playerList = document.getElementById('playerList');
  const usernameLabel = document.getElementById('username');
  const countLabel = document.getElementById('count');
  const rightPane = document.getElementById('right');
  const hud = document.getElementById('hud');
  const editorBtn = document.getElementById('editorBtn');

  // --- Constants ---
  const SIZE = { w: 40, h: 60 };
  const materialColors = {
    normal: "#888",
    ice: "#3b82f6",
    lava: "#ef4444",
    bounce: "#facc15",
    sticky: "#10b981"
  };

  // --- Safe DOM checks ---
  function assertEl(el, id) {
    if (!el) throw new Error(`Missing element: ${id}`);
    return el;
  }
  assertEl(canvas, 'canvas');
  assertEl(messages, 'messages');
  assertEl(chatForm, 'chatForm');
  assertEl(chatInput, 'chatInput');
  assertEl(playerList, 'playerList');
  assertEl(usernameLabel, 'username');
  assertEl(countLabel, 'count');
  assertEl(rightPane, 'right');
  assertEl(hud, 'hud');
  assertEl(editorBtn, 'editorBtn');

  // --- Canvas Resize with DPR ---
  function resizeCanvas() {
    const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    const w = Math.max(0, window.innerWidth - rightPane.offsetWidth);
    const h = Math.max(0, window.innerHeight - hud.offsetHeight);
    canvas.style.width = `${w}px`;
    canvas.style.height = `${h}px`;
    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }

  let resizeRAF = null;
  function queueResize() {
    if (resizeRAF) return;
    resizeRAF = requestAnimationFrame(() => {
      resizeRAF = null;
      resizeCanvas();
    });
  }
  queueResize();
  window.addEventListener('resize', queueResize);

  // --- Navigation ---
  editorBtn.addEventListener('click', () => {
    window.location.href = '/map-editor.html';
  });

  // --- Game State ---
  let myUsername = null;
  let world = null;
  let players = Object.create(null);

  // --- Socket Events ---
  socket.on('connect_error', () => {
    // optionally show a message in UI if needed
  });

  socket.on('auth', ({ username }) => {
    myUsername = username;
    usernameLabel.textContent = `You: ${username}`;
  });

  socket.on('world', ({ world: w, players: p }) => {
    world = w || null;
    players = p ? { ...p } : Object.create(null);
    updatePlayerList();
  });

  socket.on('player join', ({ username, state }) => {
    if (!username) return;
    players[username] = state || {};
    updatePlayerList();
  });

  socket.on('player leave', ({ username }) => {
    if (!username) return;
    delete players[username];
    updatePlayerList();
  });

  socket.on('state', (serverPlayers) => {
    if (serverPlayers && typeof serverPlayers === 'object') {
      players = serverPlayers;
      updatePlayerList();
    }
  });

  // --- Prevent page scroll on game keys ---
  window.addEventListener('keydown', (e) => {
    const keys = ['ArrowLeft', 'ArrowRight', 'ArrowUp', ' '];
    if (keys.includes(e.key)) e.preventDefault();
  }, { passive: false });

  // --- Input Handling ---
  const input = { left: false, right: false, up: false };
  const keymap = {
    ArrowLeft: 'left', ArrowRight: 'right', ArrowUp: 'up',
    a: 'left', d: 'right', w: 'up', ' ': 'up'
  };

  function emitInput() {
    socket.emit('input', input);
  }

  window.addEventListener('keydown', (e) => {
    const k = keymap[e.key];
    if (!k || input[k]) return;
    input[k] = true;
    emitInput();
  });

  window.addEventListener('keyup', (e) => {
    const k = keymap[e.key];
    if (!k) return;
    input[k] = false;
    emitInput();
  });

  // --- Chat ---
  chatForm.addEventListener('submit', (e) => {
    e.preventDefault();
    const text = chatInput.value.trim();
    if (!text) return;
    socket.emit('chat message', text);
    chatInput.value = '';
  });

  socket.on('chat history', (history) => {
    messages.innerHTML = '';
    if (Array.isArray(history)) history.forEach(addMessage);
  });

  socket.on('chat message', addMessage);

  function addMessage(msg) {
    if (!msg) return;
    const li = document.createElement('li');
    const time = document.createElement('span');
    time.className = 'time';
    const ts = msg.time ? new Date(msg.time) : new Date();
    time.textContent = ts.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    li.textContent = `${msg.user || 'Unknown'}: ${msg.text || ''}`;
    li.appendChild(time);
    if (msg.user && msg.user === myUsername) li.classList.add('self');
    messages.appendChild(li);
    messages.scrollTop = messages.scrollHeight;
  }

  // --- Player List ---
  function updatePlayerList() {
    playerList.innerHTML = '';
    const names = Object.keys(players);
    for (const u of names) {
      const li = document.createElement('li');
      const dot = document.createElement('div');
      dot.className = 'dot';
      dot.style.background = (players[u] && players[u].color) || '#3b82f6';
      li.appendChild(dot);
      li.appendChild(document.createTextNode(u));
      playerList.appendChild(li);
    }
    countLabel.textContent = `Players: ${names.length}`;
  }

  // --- Collision Helpers (world coords) ---
  function getRotRectCorners(p) {
    const cx = p.x + p.w / 2;
    const cy = p.y + p.h / 2;
    const rad = ((p.rotation || 0) * Math.PI) / 180;
    const local = [
      { x: -p.w/2, y: -p.h/2 },
      { x:  p.w/2, y: -p.h/2 },
      { x:  p.w/2, y:  p.h/2 },
      { x: -p.w/2, y:  p.h/2 }
    ];
    return local.map(v => ({
      x: cx + v.x * Math.cos(rad) - v.y * Math.sin(rad),
      y: cy + v.x * Math.sin(rad) + v.y * Math.cos(rad)
    }));
  }

  function getAABBCorners(ax, ay, aw, ah) {
    return [
      { x: ax,     y: ay     },
      { x: ax+aw,  y: ay     },
      { x: ax+aw,  y: ay+ah  },
      { x: ax,     y: ay+ah  }
    ];
  }

  function pointInPolygon(px, py, corners) {
    let inside = false;
    for (let i = 0, j = corners.length - 1; i < corners.length; j = i++) {
      const xi = corners[i].x, yi = corners[i].y;
      const xj = corners[j].x, yj = corners[j].y;
      const intersect = ((yi > py) !== (yj > py)) &&
                        (px < (xj - xi) * (py - yi) / (yj - yi) + xi);
      if (intersect) inside = !inside;
    }
    return inside;
  }

  function project(corners, axis) {
    let min = Infinity, max = -Infinity;
    for (const c of corners) {
      const s = (c.x * axis.x + c.y * axis.y);
      if (s < min) min = s;
      if (s > max) max = s;
    }
    return { min, max };
  }

  function normalize(v) {
    const len = Math.hypot(v.x, v.y);
    return len ? { x: v.x / len, y: v.y / len } : { x: 0, y: 0 };
  }

  // AABB vs rotated rect (SAT + corner overlap fallback)
  function aabbVsRotRect(ax, ay, aw, ah, plat) {
    const rc = getRotRectCorners(plat);
    const pc = getAABBCorners(ax, ay, aw, ah);

    // Quick corner-overlap fallback (robust for “touching”)
    for (const c of pc) if (pointInPolygon(c.x, c.y, rc)) return true;
    for (const c of rc) if (c.x >= ax && c.x <= ax + aw && c.y >= ay && c.y <= ay + ah) return true;

    // SAT axes: two unique edges of rotated rect + x/y
    const axes = [
      normalize({ x: rc[1].x - rc[0].x, y: rc[1].y - rc[0].y }),
      normalize({ x: rc[3].x - rc[0].x, y: rc[3].y - rc[0].y }),
      { x: 1, y: 0 }, { x: 0, y: 1 }
    ];
    for (const axis of axes) {
      const pProj = project(pc, axis);
      const rProj = project(rc, axis);
      if (pProj.max < rProj.min || rProj.max < pProj.min) return false;
    }
    return true;
  }

  // --- Drawing ---
  function drawPlatform(plat) {
    ctx.save();
    ctx.translate(plat.x + plat.w/2, plat.y + plat.h/2);
    ctx.rotate((plat.rotation || 0) * Math.PI/180);
    ctx.fillStyle = materialColors[plat.material] || "#888";
    ctx.fillRect(-plat.w/2, -plat.h/2, plat.w, plat.h);
    ctx.restore();
  }

  function drawPlayer(u, p) {
    ctx.save();
    ctx.translate(p.x + SIZE.w/2, p.y + SIZE.h/2);
    ctx.rotate((p.currentRotation || 0) * Math.PI / 180);

    // Body
    ctx.fillStyle = p.color || '#a3e635';
    ctx.fillRect(-SIZE.w/2, -SIZE.h/2, SIZE.w, SIZE.h);

    // Eye (relative to rotated body)
    ctx.fillStyle = '#000';
    const eyeOffsetX = p.dir === 1 ? SIZE.w/2 - 12 : -SIZE.w/2 + 4;
    ctx.fillRect(eyeOffsetX, -SIZE.h/2 + 16, 8, 8);

    // Username
    ctx.fillStyle = '#e5e7eb';
    ctx.font = '12px Segoe UI';
    ctx.textBaseline = 'bottom';
    ctx.fillText(u, -SIZE.w/2, -SIZE.h/2 - 6);

    ctx.restore();
  }

  // --- Camera helpers ---
  function clamp(val, min, max) {
    return Math.max(min, Math.min(val, max));
  }

  // --- Render Loop ---
  let running = true;
  function render() {
    if (!running) return;
    if (!world) {
      requestAnimationFrame(render);
      return;
    }

    const me = players[myUsername];
    const viewW = canvas.clientWidth;
    const viewH = canvas.clientHeight;

    const camX = clamp((me?.x || 0) - viewW / 2, 0, Math.max(0, (world.width || 0) - viewW));
    const camY = clamp((me?.y || 0) - viewH / 2, 0, Math.max(0, (world.height || 0) - viewH));

    ctx.clearRect(0, 0, viewW, viewH);
    ctx.save();
    ctx.translate(-camX, -camY);

    // Background
    ctx.fillStyle = '#222';
    ctx.fillRect(0, 0, world.width || 0, world.height || 0);

    // Platforms
    const plats = Array.isArray(world?.platforms) ? world.platforms : [];
    for (const plat of plats) drawPlatform(plat);

    // Players
    for (const [u, p] of Object.entries(players)) {
      // Detect slope under player (world coords, not screen)
      let targetRotation = 0;
      for (const plat of plats) {
        if (
          aabbVsRotRect(
            p.x, p.y,
            SIZE.w, SIZE.h,
            plat
          )
        ) {
          targetRotation = plat.rotation || 0;
          break;
        }
      }

      // Smooth rotation toward slope with snap threshold
      if (p.currentRotation === undefined) p.currentRotation = 0;
      const lerpFactor = 0.15;   // speed of easing
      const snapThreshold = 0.5; // degrees to snap when close
      let delta = targetRotation - p.currentRotation;

      // Wrap for shortest path (-180..180)
      delta = ((delta + 180) % 360) - 180;

      if (Math.abs(delta) < snapThreshold) {
        p.currentRotation = targetRotation;
      } else {
        p.currentRotation += delta * lerpFactor;
        // Optional clamp for extremes
        if (p.currentRotation > 89) p.currentRotation = 89;
        if (p.currentRotation < -89) p.currentRotation = -89;
      }

      drawPlayer(u, p);
    }

    ctx.restore();
    requestAnimationFrame(render);
  }

  // --- Start Render Loop ---
  requestAnimationFrame(render);
</script>

</body>
</html>
